%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CPS 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Elements  % STKLIK: comment the next two lines, because of "command already defined" error
% \newcommand{\CPSCyberPart}{\p{CyberPart}\xspace}
% \newcommand{\CPSPhysicalPart}{\p{PhysicalPart}\xspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MPM 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MegaModel
\newcommand{\CPSLabMM}{\p{CPSLabMM}\xspace}

% MegaModelFragments
\newcommand{\CPSLabMTMMF}{\p{CPSLabMTMMF}\xspace}
\newcommand{\CPSLabMiLMMF}{\p{CPSLabMiLMMF}\xspace}
\newcommand{\CPSLabRPaMMF}{\p{CPSLabRPaMMF}\xspace}
\newcommand{\CPSLabRPbMMF}{\p{CPSLabRPbMMF}\xspace}
\newcommand{\CPSLabSiLaMMF}{\p{CPSLabSiLaMMF}\xspace}
\newcommand{\CPSLabSiLbMMF}{\p{CPSLabSiLbMMF}\xspace}
\newcommand{\CPSLabHiLMMF}{\p{CPSLabHiLMMF}\xspace}

% Languages
\newcommand{\MATLABSimulinkLanguage}{\p{MATLAB/Simulink Language}\xspace}
\newcommand{\FESTORobotinoSimLanguage}{\p{FESTO Robotino{\copyright}Sim Language}\xspace}
\newcommand{\AUTOSARLanguage}{\p{AUTOSAR Language}\xspace}


% Models
\newcommand{\CPSLabControlModel}{\p{ControlModel}\xspace}
\newcommand{\CPSLabControlModelCode}{\p{ControlCode}\xspace}
\newcommand{\CPSLabPlantModel}{\p{PlantModel}\xspace}
\newcommand{\CPSLabRobotModel}{\p{RobotModel}\xspace}
\newcommand{\CPSLabSystemModel}{\p{SystemModel}\xspace}
\newcommand{\CPSLabSystemModelCode}{\p{SystemCode}\xspace}
\newcommand{\CPSLabSystemModels}{multiple {\CPSLabControlModel}s and one \CPSLabSystemModel\xspace}

% Tools
\newcommand{\MATLABSimulinkEditor}{\p{MATLAB/Simulink Editor}\xspace}
\newcommand{\MATLABSimulinkSimulator}{\p{MATLAB/Stateflow Simulator}\xspace}
\newcommand{\dSPACETargetLink}{\p{dSPACE TargetLink}\xspace}
\newcommand{\dSPACESystemDesk}{\p{dSPACE SystemDesk}\xspace}
\newcommand{\FESTORobotinoSim}{\p{FESTO Robotino{\copyright}Sim}\xspace}
\newcommand{\FESTORobotinoView}{\p{FESTO Robotino{\copyright}View}\xspace}
\newcommand{\DesktopExecution}{\p{Execution on a Desktop computer}\xspace}
\newcommand{\RobotExecutionLocal}{\p{Local execution on a Robotino Robot}\xspace}
\newcommand{\RobotExecutionRemote}{\p{Remote execution on a Robotino Robot}\xspace}


% =====================================================
\addtocounter{footnote}{1}
\section{HPI CPSLab$^{\thefootnote{}}$}\footnotetext[\thefootnote{}]{Acknowledgements: We thank Sebastian W{\"a}tzoldt, Stefan Neumann, Joachim H{\"a}nsel, and Falk Benke for their contributions to the lab described in this section and their contribution to the presented content and figures.}

%\LEAD{Soumyadip}\ALSO{Holger, Dominique}\STATUS{%
%Soumyadip has added some figures from the Pisa keynote and the BX/MX Dagstuhl seminar; 
%Holger restructured the text to reflect the three stages of the ontology; 
%Holger added mappings to the ontologies; 
%STILL TO BE DONE: 
%model the introduced ontology elements in the catalog or CPSLab ontology; 
%add graphics showing the added concepts/instances of the ontologies
%}

To structure the presentation of this case study according to the efforts for the MPM4CPS project, we will
%
at first in Section~\ref{subsec:cpslab-overview} provide an overview about the case study and lab,
%
then in Section~\ref{subsec:cpslab-cps} review the technical setting and derive the required needs concerning the CPS ontology,
%
thereafter in Section~\ref{subsec:cpslab-mpm} we will outline how the models, tools, and tool chain employed in the case study can be captured as multi-paradigm modeling and derive the required needs concerning the MPM ontology, and
%
finally in Section~\ref{subsec:cpslab-mpm4cps} we discuss how the CPS character of the case study is reflected in its multi-paradigm modeling and the use of the MPM4CPS ontology.

% ========================================================================================
\subsection{Overview}\label{subsec:cpslab-overview}


As outlined in more details from a conceptual point of view\uidx{ViewPoint} in \cite{Waetzoldt:2012pa}, the presented \emph{CPSLab}\footnote{http://www.cpslab.de} at the Hasso Plattner Institute (HPI)\footnote{http://www.hpi.de} at the University of Potsdam applied, adapted, and evaluated an existing industrial-strength development methodology from the automotive domain \cite{Broekman&Notenboom2003} (see also Figure~\ref{fig:methodology}) for the robotic system application domain\uidx{ApplicationDomain}. We therefore evaluated and adapted a component-based\uidx{Component} approach using an MDE approach supporting the combination of soft and hard real-time behavior\uidx{BehaviouralCharacteristic}.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.66\textwidth]{figures/methodology.pdf}
\caption{Overview of the methodology for modeling, verification, and validation employing simulation and testing (see \cite{Broekman&Notenboom2003})}
\label{fig:methodology}
\end{figure}

The resulting methodology for robotic systems supports several development activities such as modeling, simulation, verification/testing at different stages, prototyping and pre-production. The lab supports tools and related libraries in an integrated tool-chain that reflects physical and cyber aspects of distributed\uidx{Distributed} robotics systems.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.8\textwidth]{figures/evaluation_scenario_2.pdf}
\caption{Photo of the lab (see \cite{Waetzoldt:2012pa})}
\label{fig:evaluation_scenario_2}
\end{figure}


We consider a robot system as depicted in Figure~\ref{fig:evaluation_scenario_2}, where a single robot has the duty to transport pucks as advised by the overall factory automation. The regular behavior of the robot is to move around, transport pucks, or charge its batteries. The behavior must meet strict constraints, such as preventing complete discharge of the batteries and with a lower priority, ensure to transport pucks as requested. It must also perform reasonably well with respect to some soft goals to minimize energy consumption and maximize throughput.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.8\textwidth]{figures/evaluation_scenario_1.pdf}
\caption{Structural\uidx{StructureCharacteristic} overview of the employed evaluation scenario (see \cite{Waetzoldt:2012pa})}
\label{fig:evaluation_scenario_1}
\end{figure}

Figure~\ref{fig:evaluation_scenario_1} depicts a structural\uidx{StructureCharacteristic} overview of the robot system. The whole cyber-physical evaluation scenario consists of four different rooms. In the first room, the pucks are packed and dropped for transportation in area $A_P$. A robot $R_P$ transports the puck to a second room and drops it within the sorting area $A_S$. Based on the current delivery status, the robot $R_S$ chooses one of the two booths and a band-conveyor transports the puck to the customer or stock delivery area ($A_{CD}$, $A_{SD}$) afterwards. In a third step, the robot $R_{St}$ transfers the puck to stock in $St$. The doors can be opened or closed dynamically to vary the scenario. A robot can charge its battery at one of the two charging points. Each robot acts as an autonomous unit. Therefore, the tasks transportation, sorting and stocking are independent from each other.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.8\textwidth]{figures/evaluation_scenario_3.pdf}
\caption{Photo of the employed robots (see \cite{Waetzoldt:2012pa})}
\label{fig:evaluation_scenario_3}
\end{figure}


For the evaluation of our research activities, we use our CPSLab robot laboratory consisting of three Robotino robots (see Figure~\ref{fig:evaluation_scenario_3}). The robots can be equipped with several sensors (e.g., laser scanner, infrared (IR) distance sensors, GPS-like indoor navigation systems) as well as different actuators (e.g., servo motors, omnidirectional drive, gripper). 

The general idea of our evaluation scenario is the realization of a variable production setting, where robots can transport small pucks (representing goods in a production system) to different locations. The robots must fulfill different requirements, e.g., they must provide basic functionality like moving and avoiding obstacles in hard real-time (reacting on obstacles within a few milliseconds). Further, the robots must achieve high level goals, e.g., energy saving of the battery, short routing to the destination points and optimizing the throughput while transporting the pucks. While basic functionalities, such as obstacle avoidance, must be realized in hard real-time, we use existing libraries to realize higher functionalities such as path planning or creating a map by evaluating measured distance values. The latter can rarely be realized under hard real-time constraints\uidx{Constraint} because of insufficient libraries. Furthermore, we run a RTAI Linux operating system on the robot to enable hard real-time execution.

% ========================================================================================
\subsection{CPS}\label{subsec:cpslab-cps}

In the following, we will use the details of the different development steps to outline how the development is linked to CPS and the concepts of the CPS ontology introduced in Chapter~\ref{ch:cps}.

% ============================================
\subsubsection{Simulation Stage}
%
The first step of the development process\uidx{Process} of Figure~\ref{fig:methodology} is a simulation stage that focus on the model development resp.~functional development for the employed control laws.
%
At this stage, many details resulting from the physical and cyber parts of the system are ignored resp.~simplified such as real sensor values with noise, specific effects of scheduling, the impact of communication interaction and messages, and timing/memory/computation constraints.

\begin{figure}[!htb]
\centering
\includegraphics[scale=0.33]{figures/mt.pdf}
\caption{Overview of the model test in the simulation stage of \cite{Broekman&Notenboom2003}}
\label{fig:mt}
\end{figure}

% =========================================
\subsubsubsection{Model Test}
%
In a first activity\uidx{Activity} named \emph{model test} (MT)\uidx{ModelingActivity} (see Figure~\ref{fig:mt}), a so-called one-way/one-shot simulation with MATLAB/Simulink is supported where the model of the control behavior can be stimulated by inputs to see that they react properly. This provides some confidence that the setup control behavior works as intended.

% =========================================
\subsubsubsection{Model Test - CPS Ontology}
%
In the model test as outlined in Figure~\ref{fig:mt}, the abstract control algorithm from the cyber domain for a specific function is confronted with the physics as present in the input data plus expected outcomes relevant for the function and thus we have a very simple cyber-physical setting. 
%
Thus we cover the elements \CPSCyberPart from the CPS ontology for a particular function.


\begin{figure}[!htb]
\centering
\includegraphics[scale=0.33]{figures/mil.pdf}
\caption{Overview of the model in loop simulation in the simulation stage of \cite{Broekman&Notenboom2003}}
\label{fig:mil}
\end{figure}


% =========================================
\subsubsubsection{Model-in-the-Loop}
%
In a second step, the model of the control behavior is combined with a MATLAB/Simulink model of the plant by means of a \emph{model-in-the-loop} (MiL) simulation as shown in Figure~\ref{fig:mil}, which uses the feedback provided by the plant model to evaluate that the control behavior is as expected. 

% =========================================
\subsubsubsection{Model-in-the-Loop - CPS Ontology}
%
The model in the loop depicted in Figure~\ref{fig:mil} in contrast, the abstract control algorithm from the cyber domain is combined with the idealized physics as present in the plant model and thus we have a simple cyber-physical setting. 
%
Here we cover thus the elements \CPSCyberPart and \CPSPhysicalPart from the CPS ontology for a particular function.



\begin{figure}[!htb]
\centering
\includegraphics[scale=0.33]{figures/rp.pdf}
\caption{Overview of the rapid prototyping in the simulation stage of \cite{Broekman&Notenboom2003}}
\label{fig:rp}
\end{figure}



% =========================================
\subsubsubsection{Rapid Prototyping}
%
As the validity of plant models is often only rather limited when it comes to sophisticated aspects of the physical behavior\uidx{BehaviouralCharacteristic}, as an additional step \emph{rapid prototyping} as depicted in  Figure~\ref{fig:rp} is supported. 
%
For smaller control behavior, the model of the control behavior is linked to the real robot such that real sensor values with noise and timing constraints\uidx{Constraint} of the environment and platform can be covered. However, specific effects of scheduling, the impact of communication interaction and messages, and memory/computation constraints remain uncovered.
%
For larger scenarios and for the multi robot scenarios a link to a real hardware setup is not feasible here. Instead we employ a model-in-the-loop (MiL) simulation where a complex environment and the communication\uidx{Communication} between the robots can be explored. While this covers the impact of communication interaction and messages, other aspects like real sensor values with noise, specific effects of scheduling and timing/memory/computation constraints are, however, not covered.

% =========================================
\subsubsubsection{Rapid Prototyping - CPS Ontology}
%
The rapid prototyping against the robot as depicted in Figure~\ref{fig:rp}, the abstract control algorithm from the cyber domain is brought together with the real physics of the robot  and thus we have clearly a cyber-physical setting. 

Our rapid prototyping being based on a sophisticated robot simulator, again the abstract control algorithm from the cyber domain is brought together with the physics as present in the sophisticated robot model of the simulator and thus we have clearly a cyber-physical setting. 

In both cases we thus cover the elements \CPSCyberPart from the CPS ontology for a particular function and the elements \CPSPhysicalPart from the CPS ontology for the part of the robot relevant for a particular function that is either simulated or considered directly.






% ============================================
\subsubsection{Prototyping Stage}
%
The second supported stage is the prototyping stage where the focus changes from models to their implementation in software or hardware and where besides the individual functions also the system architecture is covered. Due to this refined view, in particular discretization effects of the cyber part\uidx{SystemPart} that are absent in the abstract mathematical models employed in the former stage now become visible.
%
At this stage, less details are ignore resp.~simplified as step by step specific effects of scheduling, the impact of communication\uidx{Communication} interaction and messages, and timing/memory/computation constraints\uidx{Constraint} are taken into account.


\subsubsubsection{More Detailed Modeling}
%
To consider the more detailed view\uidx{View} outlined, at the prototyping stage the models must be refined such that besides the individual functions also the system architecture is defined.

\begin{figure}[!htb]
\centering
\includegraphics[scale=0.33]{figures/arch.pdf}
\caption{Overview of the definition of the software architecture in the prototyping stage of \cite{Broekman&Notenboom2003}}
\label{fig:arch}
\end{figure}

As depicted in Figure~\ref{fig:arch}, this is done by first defining components\uidx{Component} and their communication\uidx{Communication} via port types, messages, interfaces, and data types with AUTOSAR and map the beforehand considered functional parts on them. In this step, we also have to map the functionality extending the existing models and where necessary add custom implementation files.
%
In a second step, we then define the overall architecture using AUTOSAR including besides the components and their communication also task specification and the hardware configuration.


\begin{figure}[!htb]
\centering
\includegraphics[scale=0.33]{figures/map.pdf}
\caption{Overview of the mapping of the architecture to tasks and communication\uidx{Communication} in the prototyping stage of \cite{Broekman&Notenboom2003}}
\label{fig:map}
\end{figure}

As depicted in Figure~\ref{fig:map}, an important element of this refinement is also real-time constraints, e.g. to guarantee safety\uidx{Safety} constraints\uidx{Constraint}. A combination of hard and soft real-time aspects at functional as well as architectural levels must be defined including a mapping to hard and soft real-time task with proper levels for the priorities.
%Where necessary such a refinement has to preserves hard real-time constraints for basic functions and the communication has to be designed such that it also is not in conflict with any hard real-time constraints and that the interaction between hard and soft real-time behavior ensures consistent and timely data exchange.


%\subsubsubsection{Verification}
%\subsubsubsection{SiL}
%
Concerning the verification, we employ code generation at the prototyping stage and try to step by step add more and more details of the software and hardware to the picture in the following steps.

\begin{figure}[!htb]
\centering
\includegraphics[scale=0.33]{figures/sil.pdf}
\caption{Overview of software-in-the-loop (sil) simulation in the prototyping stage of \cite{Broekman&Notenboom2003}}
\label{fig:sil}
\end{figure}



% ============================================
\subsubsubsection{Software in the Loop (SiL)}
%
The \emph{software-in-the-loop} (SiL) simulation at the prototyping stage as depicted in Figure~\ref{fig:sil} requires that code generation is employed to derive code for the functional models and architectural models. In special cases, also additional manually developed code has to be integrated. Then, the code is executed and run against the available simulation of the robot and its environment.

As we are still not using the real hardware, we still ignore and simplify elements such as real sensor values with noise %and not by the simulator covered timing constraints\uidx{Constraint} 
of the environment or platform, specific effects of scheduling, and timing/memory/computation constraints of the software.

% ============================================
\subsubsubsection{Software in the Loop (SiL) - CPS Ontology}
%
The first form of software in the loop (SiL) for which the software is executed on a desktop computer against a robot simulator features that the detailed control algorithm from the cyber domain is brought together with the physics as present in the sophisticated robot model of the simulator. Therefore, we clearly have a cyber-physical setting. 

The second form of SiL for which the software is also executed on a desktop computer but against a remotely controlled robot makes that the detailed control algorithm from the cyber domain is brought together with the physics as present in the remotely controlled robot. Therefore, we clearly have a cyber-physical setting. 

In both cases we cover the elements \CPSCyberPart from the CPS ontology for the combination of all function and the elements \CPSPhysicalPart from the CPS ontology for the whole robot.

%\subsubsubsection{HiL}

\begin{figure}[!htb]
\centering
\includegraphics[scale=0.33]{figures/hil.pdf}
\caption{Overview of hardware-in-the-loop (HiL) testing in the prototyping stage of \cite{Broekman&Notenboom2003}}
\label{fig:hil}
\end{figure}


% ============================================
\subsubsubsection{Hardware in the Loop (HiL)}
%
By moving on to the lab itself, we can then also consider a \emph{hardware-in-the-loop} (HiL) simulation at the prototyping stage as sketched in Figure~\ref{fig:hil}. Besides the software that is generated or integrated, the specific characteristics of the robot hardware and lab environment and its hardware can also be experienced.

As we now employ the real hardware, we no longer ignore resp.~simplify any elements. Therefore, now real sensor values with noise, specific effects of scheduling, the impact of communication interaction and messages, and timing/memory/computation constraints\uidx{Constraint} are all considered.

% ============================================
\subsubsubsection{Hardware in the Loop (HiL) - CPS Ontology}
%
The hardware in the loop (HiL) executing the software on the robot depicted in Figure~\ref{fig:hil} ensures that the detailed control algorithm from the cyber domain is brought together with the physics as present in the robot and thus we have clearly a cyber-physical setting. 

Thus we cover the elements \CPSCyberPart from the CPS ontology for the combination of all function and the elements \CPSPhysicalPart from the CPS ontology for the whole robot.




% ============================================
\subsubsection{Pre-Production Stage}
%
In our specific setting and due to our focus on the software development, the \emph{system test} in the pre-production stage is not really different as we do not produce any system we want to sell later. In a commercial setting the robots in the prototyping, the robots in the lab would likely be equipped with more testing hardware or prototypical hardware, while in our lab only one level exists here.

The outlined methodology and tool chain adjusted from the automotive domain, provides suitable guidance due to the different focus in stages and follows where possible an MDE approach where tools and libraries are integrated such that the models drive the development. Only later the code and configuration data automatically generated from the models are employed to consider more details concerning the verification, simulation, and testing.
%
We put special focus on supporting also hard and soft real-time considerations, which are oftentimes ignored in robotic development scenarios.

%\TODONOTE{ HG: add steps when considering multiple robots? }



%\LATER{ HG: The links to the CPS ontology that are present in the case study are quite weak and so far only refer to the elements. Maybe we can refine them when the improved version of the CPS ontology is available? 
%Right now we have:
%- separation into physical and cyber elements covered by the ontology are referenced
%- maybe properties of the CPS can be added?
%}





% ========================================================================================
\subsection{MPM}\label{subsec:cpslab-mpm}

For the MPM ontology introduced in Chapter~\ref{ch:mpm}, we will in the following use the details of the different development steps to outline how the development is linked to MPM.

% ============================================
\subsubsection{Overview}
%


\SKIP{
\begin{figure}[!htb]
\centering
\includegraphics[width=0.8\textwidth]{figures/toolchain.pdf}
\caption{Overview of the employed tool chain (see \cite{Waetzoldt:2012pa})}
\label{fig:toolchain}
\end{figure}

An additional element depicted in Figure~\ref{fig:toolchain} is a prototype tool we developed to map AUTOSAR models to a real-time simulator from INCRON to permit detailed performance evaluation early on in parallel to SiL activities.
%
Another extension not depicted in Figure~\ref{fig:toolchain} is a link between the SysML tool TOPCASED and the dSPACE tool SystemDesk for AUTOSAR that permits to derive the software and hardware architecture in AUTOSAR from the SysML system engineering models.
%
However, to keep things simpler we omit both extensions in our detailed description and the sketches of the megamodels.

\begin{figure}[!htb]
\centering
\includegraphics[scale=1.25]{figures/mm.pdf}
\caption{Sketch of the megamodel of the different stages of \cite{Broekman&Notenboom2003}}
\label{fig:mm}
\end{figure}

While several tools are employed at several stages and activities, the models developed for each of these activities are quite different as visible in the megamodel depicted in Figure~\ref{fig:mm}.

}

\begin{figure}[!htb]
\centering
\includegraphics[width=0.9\textwidth]{figures/mm-hpi2.pdf}
\caption{Tool landscape and its relation to the development methdology}
\label{fig:MMFig2}
\end{figure}

%\todo{DB: Should that be part of the MPM section? HG: yes}
In Figure~\ref{fig:MMFig2} the tool landscape for developing the aforementioned robot CPS is depicted. It consists of
%
MATLAB/Simulink for modeling and simulation,
%
dSPACE SystemDesk for modeling software architecture, hardware configuration, and task mapping,
%
dSPACE TargetLink for code generation and
%
the FESTO Robotino-Library with the FESTO Robotino{\copyright}Sim simulator.

\begin{figure}[!htb]
\centering
\includegraphics[scale=0.4]{figures/CPSLabMTMMF-NEW.jpeg}
\caption{All megamodel fragments\uidx{MegamodelFragment} of the \CPSLabMM megamodel\uidx{Megamodel}}
\label{fig:MegaModelFragmentsForCPSLabMM}
\end{figure}
 
%\begin{figure}[!htb]
\begin{figure}[p]
\centering
\includegraphics[scale=0.6]{figures/slide-fig.jpg}
\caption{Overview over the megamodel fragments of the CPSLab megamodel\uidx{Megamodel} and how the models are related (dashed arrows)}
\label{fig:MMFig10}
\end{figure}

%\TODOINLINE[SB]{ HG: Please add names of the megamodelfragments to the graphics of Figure~\ref{fig:MMFig10}. We should use the names defined int the subsequent figures which show the fragments of the megamodel in our PPT-slide notation MT (see Figure \ref{fig:CPSLabMTMMF} for a case where MT (for Model Test) and  \CPSLabMTMMF (as the name of the related MegaModelFragmeent) should be added. In most case the short name (e.g., SiL) has been already added. }

%\TODOINLINE[SB]{ HG: Please remove the methodology part in Figure~\ref{fig:MMFig10} (large red boxes with MT, MiL, RP, ... as this has been shown on the former figure already. Please ove the legend to the the remaining graphicasl elements.}

On overview about the stages and activities with an emphasis on models, tools, and multi-paradigm modeling is depicted in Figure~\ref{fig:MMFig10}.

In the following, we outline to which elements of the MPM ontology of Chapter~\ref{ch:mpm} the elements of the megamodel\uidx{Megamodel} refer and which megamodel fragments\uidx{MegamodelFragment} cover the scenarios introduced in the last subsection.

%\LATER{ HG: Is an introduction to the notation required? Do we have to explain the links to the MPM ontology concepts here?}

\subsubsubsubsection{Formalism, Languages, Models, and Tools}

\LATER[Formalism]{
\item Formalism
    \begin{itemize}
        \item Automated Based Formalism: Abstract state machine, Cellular automata, Input/Output Automata, Label transitions systems, Timed transitions systems
        \item Automated Based Formalism:: Hybrid Automata: Hybrid Automata, Hybrid Input/Output automata, Linear hybrid automata, Non-Linear Hybrid Automata, Stocastics hybrid automata 
        \item Automated Based Formalism:: Hybrid Automata:: Timed Automata: , Stockists timed automata, Timed Automata, PTS.
        \item Flow Based Formalism: Data Flow, State Flow, Data Flow timed, HyFlow.
        \item Logic Based Formalism: First order logic, Linear temporal logic, CTL, Temporal Logic 
        \item Petri net based formalism: High Level Petri net, Petri net, Petri net with priyority, Petri net with time, dPN, Timed Petri net
        
    \end{itemize}
}

\begin{itemize}
    \item Used Language and Models
    \begin{itemize}
        \item \MATLABSimulinkLanguage: \CPSLabControlModel, \CPSLabPlantModel
        \item \FESTORobotinoSimLanguage: \CPSLabRobotModel
        \item \AUTOSARLanguage: \CPSLabSystemModel
    \end{itemize}
    \item MegaModel\uidx{Megamodel}
    \begin{itemize}
        \item MegaModel: \CPSLabMM
        \item MegaModelFragments\uidx{MegamodelFragment}: \CPSLabMTMMF, \CPSLabMiLMMF, \CPSLabRPaMMF, \CPSLabRPbMMF, \CPSLabSiLaMMF, \CPSLabSiLbMMF, \CPSLabHiLMMF
        \item ModelRealtions: (see detailed definition of the megamodel fragments)
    \end{itemize}
    \item Tool
    \begin{itemize}
        \item SimulationTool: \MATLABSimulinkSimulator
        \item TransformationTool: \dSPACETargetLink
        \item ModelingTool: \dSPACESystemDesk
        \item SimulationTool: \FESTORobotinoSim
        \item VisualizationTool: \FESTORobotinoView
        \item ExecutionTool: \DesktopExecution
        \item ExecutionTool: \RobotExecutionRemote
        \item ExecutionTool: \RobotExecutionLocal \LATER{ HG: check tool types!}
    \end{itemize}
\end{itemize}

%\DONE[HG]{ HG: please add scheme for MPM ontology use here! }
%\DONE[SB]{ HG: please model scheme for MPM ontology presented here with Protege! }
%\DONE[SB]{ HG: please add figure showing the used MPM ontology elements here! }



The added elements for the CPSLab ontology outlined in the text are depicted also in Figure~\ref{fig:MegaModelFragmentsForCPSLabMM}.

% ============================================
\subsubsection{Simulation Stage}
%
In the simulation stage we have two development activities: model test and model-in-the loop.
%
In the following, we will outline how they can be captured with mega-model fragments consisting of model instances and tool applications.





% =========================================
\subsubsubsection{Model Test}
%
The model test introduced in Figure~\ref{fig:mt}, is rather trivial as it only employ a single model of the planned control algorithm plus some auxiliary models for test inputs. Then, as depicted in Figure~\ref{fig:MMFig3} the model of the control algorithm is simulated by employing the test inputs.

\begin{figure}[!htb]
\centering
\includegraphics[scale=0.33]{figures/mm-hpi3.pdf}
\caption{Model Test}
\label{fig:MMFig3}
\vspace{-0.2in}
\end{figure}

% =========================================
\subsubsubsection{Model Test - MPM Ontology}
%
%
\subsubsubsubsection{MegaModel Fragment \CPSLabMTMMF}

\begin{itemize}
    \item MegaModelFragment: \CPSLabMTMMF
    \begin{itemize}
        \item Model(s): \CPSLabControlModel
    \end{itemize}
\end{itemize}

\subsubsubsubsection{Tools / Models Operations of \CPSLabMiLMMF}

\begin{itemize}
    \item \uidxp{ModelOperation}: One Shot Simulation
    \begin{itemize}
        \item Input Model(s): \CPSLabControlModel, Input data (entered with \MATLABSimulinkSimulator)
        \item Output Model(s): Output data (visualized with \MATLABSimulinkSimulator)
        \item Employed Tool: \MATLABSimulinkSimulator %\COMMENT{\tiny THIS ENTRY IS NOT COVERED BY THE ONTOLOGY SO FAR}
    \end{itemize}
\end{itemize}

%\LATER{
%\subsubsubsubsection{Development Process}
 
%FREE TEXT CAPTURING THE ORDERING
%}

%\DONE[HG]{ HG: please add scheme for MPM ontology use here! }
%\DONE[SB]{ HG: please model scheme for MPM ontology presented here with Protege! }
%\DONE[SB]{ HG: please add figure showing the used MPM ontology elements here! }

\begin{figure}[!htb]
\centering
\includegraphics[scale=0.3]{figures/CPSLabMTMMF-NEW-1.jpeg}
\caption{Part of the ontology for the megamodel fragment\uidx{MegamodelFragment} \CPSLabMTMMF covering the Model Test activity\uidx{Activity}}
\label{fig:CPSLabMTMMF}
\end{figure}

In Figure~\ref{fig:CPSLabMTMMF}, the added MegaModel Fragment \CPSLabMTMMF and its elements for the CPSLab ontology outlined in the text are presented.

% =========================================
\subsubsubsection{Model-in-the-Loop}
%
In contrast to model test, model-in-the-loop simulation as introduced in Figure~\ref{fig:mil} employed besides a model of the control algorithm also a model of the plant and uses as depicted in Figure~\ref{fig:MMFig4} simulation to explore how well both fit together.

\begin{figure}[!htb]
\centering
\includegraphics[scale=0.33]{figures/mm-hpi4.pdf}
\caption{Model in the Loop}
\label{fig:MMFig4}
\end{figure}

% =========================================
\subsubsubsection{Model-in-the-Loop - MPM Ontology}
%
\subsubsubsubsection{MegaModel Fragment \CPSLabMiLMMF}

\begin{itemize}
    \item MegaModelFragment: \CPSLabMiLMMF
    \begin{itemize}
        \item Model(s): \CPSLabControlModel, \CPSLabPlantModel
    \end{itemize}
\end{itemize}

\subsubsubsubsection{Tools / Models Operations of \CPSLabMiLMMF}

\begin{itemize}
    \item \uidxp{ModelOperation}: Model-in-the-Loop Simulation
    \begin{itemize}
        \item Input Model(s): \CPSLabControlModel, \CPSLabPlantModel
        \item Output Model(s): Output data (visualized with \MATLABSimulinkSimulator)
        \item Employed Tool: \MATLABSimulinkSimulator %\COMMENT{\tiny THIS ENTRY IS NOT COVERED BY THE ONTOLOGY SO FAR}
    \end{itemize}
\end{itemize}

%\LATER{
%\subsubsubsubsection{Development Process}
 
%FREE TEXT CAPTURING THE ORDERING
%}

%\DONE[HG]{ HG: please add scheme for MPM ontology use here! }
%\DONE[SB]{ HG: please model scheme for MPM ontology presented here with Protege! }
%\DONE[SB]{ HG: please add figure showing the used MPM ontology elements here! }

\begin{figure}[!htb]
\centering
\includegraphics[scale=0.38]{figures/CPSLabMilMMF.jpg}
\caption{Part of the ontology for the MegaModelFragment\uidx{MegamodelFragment} \CPSLabMiLMMF covering Model-in-the-Loop (MiL)}
\label{fig:CPSLabMilMMF}
\end{figure}

The added MegaModel Fragment\uidx{MegamodelFragment} \CPSLabMiLMMF and its elements for the CPSLab ontology outlined in the text are depicted also in Figure~\ref{fig:CPSLabMilMMF}.

% =========================================
\subsubsubsection{Rapid Prototyping}
%
The rapid prototyping as introduced in Figure~\ref{fig:rp} is supported in two forms.
%
At first rapid prototyping can be done employing a sophisticated simulator for the robot as depicted in Figure~\ref{fig:MMFig5}. While not necessary exposing the control algorithm to physical reality as far as captured by the sophisticated model of the robot, the simulator already capture much more details than the plan model while still allowing to analyze the behavior much easier then in the case of using the real robot.

\begin{figure}[!htb]
\centering
\includegraphics[scale=0.4]{figures/mm-hpi5.pdf}
\caption{Rapid Prototyping (RP) with a detailed robot simulation}
\label{fig:MMFig5}
\end{figure}

The second case depicted in Figure~\ref{fig:MMFig6} connects the abstract control algorithm with the real robot and therefore expose the algorithm to all physical effects. However, analysis might be difficult as running the algorithm against the robot is less easy to analyze then when running it against a simulator.

\begin{figure}[!htb]
\centering
\includegraphics[scale=0.33]{figures/mm-hpi6.pdf}
\caption{Rapid Prototyping (RP) with a remote controlled robot}
\label{fig:MMFig6}
\end{figure}

% =========================================
\subsubsubsection{Rapid Prototyping - MPM Ontology}
%
%
\subsubsubsubsection{MegaModel Fragment \CPSLabRPaMMF}

\begin{itemize}
    \item MegaModelFragment: \CPSLabRPaMMF
    \begin{itemize}
        \item Model(s): \CPSLabControlModel, \CPSLabRobotModel
    \end{itemize}
\end{itemize}

\subsubsubsubsection{Tools / Models Operations of \CPSLabRPaMMF}

\begin{itemize}
    \item ModelOperation: Rapid Prototyping with Robot Simulation
    \begin{itemize}
        \item Input Model(s): \CPSLabControlModel, \CPSLabRobotModel
        \item Output Model(s): Output data (visualized with \MATLABSimulinkSimulator and/or \FESTORobotinoView)
        \item Employed Tool: \MATLABSimulinkSimulator, \FESTORobotinoSim %\COMMENT{\tiny THIS ENTRY IS NOT COVERED BY THE ONTOLOGY SO FAR}
    \end{itemize}
\end{itemize}


\begin{figure}[!htb]
\centering
\includegraphics[scale=0.333]{figures/CPSLabRPaMMF.jpg}
\caption{Part of the ontology for the MegaModelFragment \CPSLabRPaMMF covering Rapid Prototyping with Robot Simulation}
\label{fig:CPSLabRPaMMF}
\end{figure}


In Figure~\ref{fig:CPSLabRPaMMF}, the added MegaModel Fragment\uidx{MegamodelFragment} \CPSLabRPaMMF and its elements for the CPSLab ontology outlined in the text are presented.

%\LATER{
%\subsubsubsubsection{Development Process}
 
%FREE TEXT CAPTURING THE ORDERING
%}

\subsubsubsubsection{MegaModel Fragment \CPSLabRPbMMF}

\begin{itemize}
    \item MegaModelFragment: \CPSLabRPbMMF
    \begin{itemize}
        \item Model(s): \CPSLabControlModel
    \end{itemize}
\end{itemize}

\subsubsubsubsection{Tools / Models Operations of \CPSLabRPbMMF}

\begin{itemize}
    \item ModelOperation: Rapid Prototyping with Robot Execution
    \begin{itemize}
        \item Input Model(s): \CPSLabControlModel
        \item Output Model(s): Output data (visualized with \MATLABSimulinkSimulator and/or observed)
        \item Employed Tool: \MATLABSimulinkSimulator, \RobotExecutionRemote %\COMMENT{\tiny THIS ENTRY IS NOT COVERED BY THE ONTOLOGY SO FAR}
    \end{itemize}
\end{itemize}

%\LATER{
%\subsubsubsubsection{Development Process}
 
%FREE TEXT CAPTURING THE ORDERING
%}

\begin{figure}[!htb]
\centering
\includegraphics[scale=0.333]{figures/CPSLabRPbMMF.jpg}
\caption{Part of the ontology for MegaModelFragment \CPSLabRPbMMF covering Rapid Prototyping with Robot Execution}
\label{fig:CPSLabRPbMMF}
\end{figure}


The added MegaModel Fragment \CPSLabRPbMMF and its elements for the CPSLab ontology outlined in the text are depicted also in Figure~\ref{fig:CPSLabRPbMMF}.

%\DONE[HG]{ HG: please add scheme for MPM ontology use here! }
%\DONE[SB]{ HG: please model scheme for MPM ontology presented here with Protege! }
%\DONE[SB]{ HG: please add figure showing the used MPM ontology elements here! }



% =========================================
\subsubsubsection{Simulation Stage - MPM Ontology}
%
Some issues are not yet covered by the MPM ontology and the employed megamodel\uidx{Megamodel} and megamodel fragments\uidx{MegamodelFragment}: 
%
While the same types of models and tools are employed at several stages and activities as visible in the megamodel depicted in Figure~\ref{fig:MMFig10}, the models developed for each of these activities are quite different in the simulation stage.
%
For the model test, only simply MATLAB Simulink models with the standard block set and input signals are usually employed. 
%
For the model-in-the-loop simulation, both the model of the control behavior and of the related fragment of the plant are modeled and evaluated using MATLAB/Simulink models with the standard block set.
%
To link the behavior to the FESTO Robotino{\copyright}Sim Simulator and visualize the outcome with FESTO Robotino{\copyright}View, a specific block set compatible with the FESTO Robotino-Library is employed.






% ===============================================
\subsubsection{Prototyping}
%


% ============================================
\subsubsection{Software in the Loop (SiL)}
%
Software in the Loop (SiL) as introduced in Figure~\ref{fig:sil}, can actually be done in different ways:
%
A first version executes the generated software on a desktop computer and runs it against a simulator as depicted in Figure~\ref{fig:MMFig7}.

\begin{figure}[!htb]
\centering
\includegraphics[scale=0.33]{figures/mm-hpi7.pdf}
\caption{Software in the Loop (SiL) vs. Desktop + Sim}
\label{fig:MMFig7}
\end{figure}

A second form executes the generated software  on a desktop computer and in contrast to the first form links it to the robot as depicted in Figure~\ref{fig:MMFig8}.

\begin{figure}[!htb]
\centering
\includegraphics[scale=0.33]{figures/mm-hpi8.pdf}
\caption{Software in the Loop (SiL) vs. Desktop + Robot}
\label{fig:MMFig8}
\end{figure}

% =========================================
\subsubsubsection{Software in the Loop (SiL) - MPM Ontology}
%
\subsubsubsubsection{MegaModel Fragment \CPSLabSiLaMMF}

\begin{itemize}
    \item MegaModelFragment: \CPSLabSiLaMMF
    \begin{itemize}
        \item Model(s): \CPSLabControlModel*, \CPSLabSystemModel, \CPSLabRobotModel
    \end{itemize}
\end{itemize}

\subsubsubsubsection{Tools / Models Operations of \CPSLabSiLaMMF}

\begin{itemize}
    \item ModelOperation: FunctionCodeGeneration*
    \begin{itemize}
        \item Input Model(s): \CPSLabControlModel
        \item Output Model(s): \CPSLabControlModelCode
        \item Employed Tool: \dSPACETargetLink %\COMMENT{\tiny THIS ENTRY IS NOT COVERED BY THE ONTOLOGY SO FAR}
    \end{itemize}
    \item ModelOperation: SystemCodeGeneration
    \begin{itemize}
        \item Input Model(s): \CPSLabSystemModel
        \item Output Model(s): \CPSLabSystemModelCode
        \item Employed Tool: \dSPACESystemDesk %\COMMENT{\tiny THIS ENTRY IS NOT COVERED BY THE ONTOLOGY SO FAR}
    \end{itemize}
    \item ModelOperation: Software-in-the-Loop Simulation
    \begin{itemize}
        \item Input Model(s): \CPSLabControlModelCode*, \CPSLabSystemModelCode, \CPSLabRobotModel
        \item Output Model(s): Output data (visualized with \MATLABSimulinkSimulator and/or \FESTORobotinoView)
        \item Employed Tool: \DesktopExecution, \FESTORobotinoSim %\COMMENT{\tiny THIS ENTRY IS NOT COVERED BY THE ONTOLOGY SO FAR}
    \end{itemize}
\end{itemize}

%\LATER{
%\subsubsubsubsection{Development Process}
 
%FREE TEXT CAPTURING THE ORDERING
%}

\begin{figure}[!htb]
\centering
\includegraphics[scale=0.333]{figures/CPSLabSiLaMMF.jpg}
\caption{Part of the ontology for the MegaModelFragment \CPSLabSiLaMMF covering SiL with Simulation}
\label{fig:CPSLabSiLaMMF}
\end{figure}

The added MegaModel Fragment \CPSLabSiLaMMF and its elements for the CPSLab ontology outlined in the text are depicted also in Figure~\ref{fig:CPSLabSiLaMMF}.


%\DONE[HG]{ HG: please add scheme for MPM ontology use here! }
%\DONE[SB]{ HG: please model scheme for MPM ontology presented here with Protege! }
%\DONE[SB]{ HG: please add figure showing the used MPM ontology elements here! }

\subsubsubsubsection{MegaModel Fragment \CPSLabSiLbMMF}

\begin{itemize}
    \item MegaModelFragment: \CPSLabSiLbMMF
    \begin{itemize}
        \item Model(s): \CPSLabControlModel*, \CPSLabSystemModel
    \end{itemize}
\end{itemize}

\subsubsubsubsection{Tools / Models Operations of \CPSLabSiLbMMF}

\begin{itemize}
    \item ModelOperation: FunctionCodeGeneration*
    \begin{itemize}
        \item Input Model(s): \CPSLabControlModel
        \item Output Model(s): \CPSLabControlModelCode
        \item Employed Tool: \dSPACETargetLink %\COMMENT{\tiny THIS ENTRY IS NOT COVERED BY THE ONTOLOGY SO FAR}
    \end{itemize}
    \item ModelOperation: SystemCodeGeneration
    \begin{itemize}
        \item Input Model(s): \CPSLabSystemModel
        \item Output Model(s): \CPSLabSystemModelCode
        \item Employed Tool: \dSPACESystemDesk %\COMMENT{\tiny THIS ENTRY IS NOT COVERED BY THE ONTOLOGY SO FAR}
    \end{itemize}
    \item ModelOperation: Software-in-the-Loop Execution
    \begin{itemize}
        \item Input Model(s): \CPSLabControlModelCode*, \CPSLabSystemModelCode
        \item Output Model(s): Output data (visualized with \MATLABSimulinkSimulator and/or observed)
        \item Employed Tool: \RobotExecutionRemote, \DesktopExecution %\COMMENT{\tiny THIS ENTRY IS NOT COVERED BY THE ONTOLOGY SO FAR}
    \end{itemize}
\end{itemize}

%\LATER{
%\subsubsubsubsection{Development Process}
 
%FREE TEXT CAPTURING THE ORDERING
%}

%\DONE[HG]{ HG: please add scheme for MPM ontology use here! }
%\DONE[SB]{ HG: please model scheme for MPM ontology presented here with Protege! }
%\DONE[SB]{ HG: please add figure showing the used MPM ontology elements here! }

\begin{figure}[!htb]
\centering
\includegraphics[scale=0.333]{figures/CPSLabSiLbMMF.jpg}
\caption{Part of the ontology for the MegaModelFragment\uidx{MegamodelFragment} \CPSLabSiLbMMF covering Sil with Execution}
\label{fig:CPSLabSiLbMMF}
\end{figure}

The added MegaModel Fragment \CPSLabSiLbMMF and its elements for the CPSLab ontology outlined in the text are depicted also in Figure~\ref{fig:CPSLabSiLbMMF}.


% ============================================
\subsubsection{Hardware in the Loop (HiL)}
%
Hardware in the Loop (HiL) as introducted in Figure~\ref{fig:hil} in contrast links the generated software such that it can be executed on the robot as depicted in Figure~\ref{fig:MMFig9}.

\begin{figure}[!htb]
\centering
\includegraphics[scale=0.33]{figures/mm-hpi9.pdf}
\caption{Hardware in the Loop (HiL)}
\label{fig:MMFig9}
\end{figure}

% =========================================
\subsubsubsection{Hardware in the Loop (HiL) - MPM Ontology}
%
\subsubsubsubsection{MegaModel Fragment \CPSLabHiLMMF}

\begin{itemize}
    \item MegaModelFragment: \CPSLabHiLMMF
    \begin{itemize}
        \item Model(s): \CPSLabControlModel*, \CPSLabSystemModel
    \end{itemize}
\end{itemize}

\subsubsubsubsection{Tools / Models Operations of \CPSLabHiLMMF}

\begin{itemize}
    \item ModelOperation: FunctionCodeGeneration*
    \begin{itemize}
        \item Input Model(s): \CPSLabControlModel
        \item Output Model(s): \CPSLabControlModelCode
        \item Employed Tool: \dSPACETargetLink %\COMMENT{\tiny THIS ENTRY IS NOT COVERED BY THE ONTOLOGY SO FAR}
    \end{itemize}
    \item ModelOperation: SystemCodeGeneration
    \begin{itemize}
        \item Input Model(s): \CPSLabSystemModel
        \item Output Model(s): \CPSLabSystemModelCode
        \item Employed Tool: \dSPACESystemDesk %\COMMENT{\tiny THIS ENTRY IS NOT COVERED BY THE ONTOLOGY SO FAR}
    \end{itemize}
    \item ModelOperation: Hardware-in-the-Loop Execution
    \begin{itemize}
        \item Input Model(s): \CPSLabControlModelCode*, \CPSLabSystemModelCode
        \item Output Model(s): Output data (observed)
        \item Employed Tool: \RobotExecutionLocal %\COMMENT{\tiny THIS ENTRY IS NOT COVERED BY THE ONTOLOGY SO FAR}
    \end{itemize}
\end{itemize}

%\LATER{
%\subsubsubsubsection{Development Process}
 
%FREE TEXT CAPTURING THE ORDERING
%}

%\DONE[HG]{ HG: please add scheme for MPM ontology use here! }
%\DONE[SB]{ HG: please model scheme for MPM ontology presented here with Protege! }
%\DONE[SB]{ HG: please add figure showing the used MPM ontology elements here! }

\begin{figure}[!htb]
\centering
\includegraphics[scale=0.333]{figures/CPSLabHiLMMF.jpg}
\caption{Part of the ontology for the MegaModelFragment \CPSLabHiLMMF covering Hil}
\label{fig:MMF-HPI-HiL}
\end{figure}

The added MegaModel Fragment\uidx{MegamodelFragment} \CPSLabHiLMMF and its elements for the CPSLab ontology outlined in the text are depicted also in Figure~\ref{fig:MMF-HPI-HiL}.


% =========================================
\subsubsubsection{Prototyping - MPM Ontology}
%
Again, the MPM ontology and the employed megamodel\uidx{Megamodel} and megamodel fragments\uidx{MegamodelFragment} do not cover all issues: 
%
In contrast to the restriction to MATLAB/Simulink during the simulation stage, for the prototyping stage also dSPACE SystemDesk for describing a component-based\uidx{Component} architecture with AUTOSAR must be considered as well as outlined above and depicted in the megamodel presented in Figure~\ref{fig:MMFig10}.
%
For the software-in-the-loop simulation, it is necessary to adjust the functional models to the specific dSPACE TargetLink block set such that the dSPACE TargetLink for code generation can be employed. In addition, dSPACE SystemDesk is employed to define the software architecture, hardware configuration, and task mapping with AUTOSAR. Then, this combination of models is linked via the blocks for the FESTO Robotino-Library and simulated by linking the MATLAB/Simulink and FESTO Robotino{\copyright}Sim simulators and  the outcome is visualized with FESTO Robotino{\copyright}View. 
%
In case of the hardware-in-the-loop testing, the same block set for the FESTO Robotino-Library can be reconfigured such that 
%
either the compiled software runs on a host computer and controls the Robotino robots remotely
%
or the compiled and linked software runs directly on the Robotino robots.


% ========================================================================================
\subsection{MPM4CPS}\label{subsec:cpslab-mpm4cps}
%
In order to discuss the role of MPM for CPS development as presented in the case study, we refer to the inherent integration needs underlying the development of embedded real-time systems and cyber-physical systems in particular as outlined in \cite{GieseNNS2011}. Furthermore, we link these observations to the MPM4CPS ontology as presented in Chapter~\ref{ch:mpm4cps} and further needs to extend it.
We present the modeling of this process and of one of its employed modeling paradigms with the MPM4CPS ontology. We first present the modeling of the methodology and its stages. Then, for each stage we present the detailed modeling of the different activities implementing the stage, including the employed viewpoints. Finally, we present the modeling of a simple modeling paradigm employed by the HPI CPSLab process and its viewpoints.
% ============================================
\subsubsection{Methodology}

We define the CPSLabMethodology instance of the \uidxp{EngineeringMethodology} class of the workflow subdomain of shared ontology (Chapter~\ref{ch:foundations:introduction}) to capture the HPI CPSLab methodology and its set of stages as depicted in Figure~\ref{fig:introduction.methodology}. This is achieved by representing each stage as an instance of the \uidxp{EngineeringStage} class and creating instances of the \uidxp{hasNextStage} object property defining the order between the stages.
\\
\\
\noindent\uline{Methodology}
\begin{itemize}
\item EngineeringMethodology: CPSLabMethodology
\begin{itemize}
    \item hasStages EngineeringStage: \texttt{CPSLabSimulationStage}
    \begin{itemize}
        \item hasNextStage: \texttt{CPSLabPrototypingStage}
    \end{itemize}
    \item hasStages EngineeringStage: \texttt{CPSLabPrototypingStage}
    \begin{itemize}
        \item hasNextStage: \texttt{CPSLabPreproductionStage}
    \end{itemize}
    \item hasStages EngineeringStage: \texttt{CPSLabPreproductionStage}
\end{itemize}
\end{itemize}

\subsubsection{Methodology Implementing Process}

We define the root CPSLabProcess instance of the \uidxp{ModelBasedProcess} class to implement the CPSLabMethodology. This process defines an activity set defining root activities and transitions to orchestrate them. Each of these activities contributes to implementing a stage of the CPSLab methodology. In addition, each root activity is decomposed into finer grained activities as declared with an associated subprocess.
\\
\\
\noindent\uline{ActivitySet}
     \begin{itemize}
    \item hasSetActivities SubFlow: MTActivity
        \begin{itemize}
            \item isImplementingStage: CPSLabSimulationStage
            \item hasSubProcess: MTProcess
        \end{itemize}
    \item hasSetActivities SubFlow: MiLActivity
        \begin{itemize}
            \item isImplementingStage: CPSLabSimulationStage
            \item hasSubProcess: MiLProcess
        \end{itemize}
    \item hasSetActivities SubFlow: RPActivity
        \begin{itemize}
            \item isImplementingStage: CPSLabSimulationStage
            \item hasSubProcess: RPProcess
        \end{itemize}
    \item hasSetActivities SubFlow: SiLActivity
        \begin{itemize}
            \item isImplementingStage: CPSLabPrototypingStage
            \item hasSubProcess: SiLProcess
        \end{itemize}
    \item hasSetActivities SubFlow: HiLActivity
        \begin{itemize}
            \item isImplementingStage: CPSLabPrototypingStage
            \item hasSubProcess: HiLProcess
        \end{itemize}
    \item hasSetActivities SubFlow: STActivity
        \begin{itemize}
            \item isImplementingStage: CPSLabPreproductionStage
            \item hasSubProcess: STProcess
        \end{itemize}
    \item hasTransitions Transition: MT2MiLTransition
    \item hasTransitions Transition: MiL2RPTransition
    \item hasTransitions Transition: RP2SiLTransition
    \item hasTransitions Transition: MiL2SiLTransition
    \item hasTransitions Transition: SiL2HiLTransition
    \item hasTransitions Transition: HiL2STTransition
\end{itemize}

Transitions are instantiated with appropriate conditions (not presented here) to define the order of execution of activities. Note that the declared order must be overall consistent with the ordering of the implemented stages as defined by the methodology. Overall consistency means that activities of a stage that follows another stage should never be executed before the activities of the preceding stage have already been executed at least once. Indeed, although not shown in this case, root activity transitions may return back to an activity of a preceding stage in case the errors discovered during the current stage were introduced at an earlier stage.

In the next sections, for each stage we present the viewpoints and the root activity processes that employ them.

% ============================================
\subsubsection{Simulation Stage}
%
% =========================================
The purpose of the simulation stage is to define the control laws of the system. As opposed to the two next stages, its activities only employ models as captured by the megamodel fragments of Chapter~\ref{ch:foundations:MPM-Ontology} to represent the system and its environment.

For the HPI CPSLab example, we define a set of viewpoints specific to each of the root activities. This differs from the EBCPS example where existing viewpoints (e.g. from a library) are reused to support the activities. In this case, we define three viewpoints to support each root modeling activity of the simulation stage as follows:
\\
\\
\noindent\uline{Viewpoints}
    \begin{itemize}
         \item Viewpoint: CPSLabMTControlAlgorithmVP
         \begin{itemize}
            \item hasFramedConcerns: ControlAlgorithm
            \item hasSystemConstituentElements: Controller, Plant, Sensor, Actuator
            \item hasSupportingMegaModelFragments: CPSLabMTMMF
         \end{itemize}
        \item Viewpoint: CPSLabMiLControlAlgorithmVP
         \begin{itemize}
            \item hasFramedConcerns: ControlAlgorithm, Stability, Safety, Reliability
            \item hasSystemConstituentElements: Controller, Plant, Sensor, Actuator
            \item hasSupportingMegaModelFragments: CPSLabMiLMMF
         \end{itemize}
        \item Viewpoint: CPSLabRPControlAlgorithmVP
         \begin{itemize}
            \item hasFramedConcerns: ControlAlgorithm, Stability, Safety, Reliability
            \item hasSystemConstituentElements: Controller, Plant, Sensor, Actuator
            \item hasSupportingMegaModelFragments: CPSLabRPMMF
         \end{itemize}
    \end{itemize}

Each of these viewpoints addresses the concern of the control algorithm of the system under design and is using a megamodel fragment defined in the example section of Chapter~\ref{ch:foundations:MPM-Ontology} of the MPM ontology to capture the employed modeling languages and their relations. In addition, the CPSLabMiLControlAlgorithmVP and CPSLabRPControlAlgorithmVP also address other concerns such as stability, safety, reliability, thanks to the plant model providing feedback to the controller as opposed to the static input data of the model test activity.

Each of these viewpoints describes a cyber-physical setting, at different levels of abstraction. The abstract control algorithm from the cyber domain captured by the Matlab/Simulink control model (ControlModel) is confronted with the physics as represented in the input data plus expected outcomes. This is model differently for each viewpoint as static data model (MT), plant model (MiL) and detailed robot model (RP). Therefore, all viewpoints cover the system constituents of interest represented by these models, which are the controller, plant, sensor and actuator elements. We further have a multi-formalism setting where the control is discrete while the input data is at least conceptually continuous.
\\
\\
\noindent\uline{Root Activity Subprocesses}
\\
\\
Each root subflow activity is further described by a subprocess specifying its decomposition in terms of finer grained activities such a editing a model, executing a model transformation, etc. Besides, the process, which is responsible for defining the context for executing its activities is associated with a viewpoint providing such context. We list below the root activity sub processes and their associated viewpoints. As an example, we present the fine grained activities of the model test subprocess in the next section. 

\begin{itemize}
    \item ModelBasedProcess: CPSLabMTProcess 
        \begin{itemize}
            \item ActivitySet: ...
            \item hasViewPoint: CPSLabMTControlAlgorithmVP
        \end{itemize}
    \item ModelBasedProcess: CPSLabMiLProcess 
        \begin{itemize}
            \item ActivitySet: ...
            \item hasViewPoint: CPSLabMiLControlAlgorithmVP
        \end{itemize}
    \item ModelBasedProcess: CPSLabRPProcess 
        \begin{itemize}
            \item ActivitySet: ...
            \item hasViewPoint: CPSLabRPControlAlgorithmVP
        \end{itemize}
\end{itemize}

\noindent\uline{Model Test Subprocess (CPSLabMTProcess)}
\\
\\
We describe here as an example the set of subactivities that constitute the CPSLabMTProcess. Like for the process orchestrating root activities, this is achieved by creating a block activity and its activity set. But we first define activity performers to perform the activities.
\\
\\
\noindent\uline{Activity Performers}
     \begin{itemize}
    \item ModelingHuman: ControlEngineerPerf
        \begin{itemize}
            \item hasTranformationSpecifications: : EditInputModelOperation, EditControlModelOperation, EditPlantModelOperation, EditValidityResultsModel...
        \end{itemize}
    \item ModelingTool: SimulinkTool
        \begin{itemize}
            \item hasTranformationSpecifications: SimulateModelOperation, ...
        \end{itemize}
    \end{itemize}

Then, we define the fine grained activities as per the list below. 
\\
\\
\noindent\uline{ActivitySet}
     \begin{itemize}
    \item hasSetActivities Activity: MTEditInputModel 
        \begin{itemize}
            \item hasActivityPerformer: ControlEngineerPerf
        \end{itemize}
    \item hasSetActivities Activity: MTEditControlModel
        \begin{itemize}
            \item hasActivityPerformer: ControlEngineerPerf
        \end{itemize}
    \item hasSetActivities Activity: MTSimulateControlModel
        \begin{itemize}
            \item hasActivityPerformer: SimulinkTool
        \end{itemize}
    \item hasSetActivities Activity: MTCheckSimulationResults
        \begin{itemize}
            \item hasActivityPerformer: ControlEngineerPerf
        \end{itemize}
    \item hasTransitions Transition: EditInput2EditControlTransition
    \item hasTransitions Transition: EditControl2SimulateControlTransition
    \item hasTransitions Transition: CheckResults2EditControlTransition
        \begin{itemize}
            \item hasCondition: ValidResults
        \end{itemize}
    \item hasTransitions Transition: ...
\end{itemize}

Transitions are defined between the different activities. It should be noted that this is a simplified version of the real workflow as the order of the activities may depend on several conditions. For example, the transition CheckResults2EditControlTransition between the MTCheckSimulationResults and MTEditControlModel activities has a condition. Such condition evaluates some property of the ValidityResultsModel as was set by the designer during the MTCheckSimulationResults activity and indicating if the results are correct or not. If not correct, the control may be edited again. If correct, the process ends and by default returns to the calling subflow root activity.

At deployment, an application megamodel containing the models to be processed by activity performers can be bound to this structure for executing the process on real models.

The definition of the two other CPSLabMiLProcess and CPSLabRPProcess processes follows the same principles as that of the CPSLabMTProcess detailed above and is not presented. All details can be found in the ontology files accessible from \cite{MPM4CPS-Website}. 
\\
% ============================================
\subsubsection{Prototyping Stage}
%
% =========================================
Compared to the simulation stage, which only uses models, the focus of the prototyping stage changes from design to implementation. In this stage, the source code plays a major role and is gradually incorporated into the system under development. The purpose is to ensure that implementation constraints such as discretization of variables and time due to the limited resources of the execution platform are handled appropriately to meet the system requirements. The concerns of this stage are therefore related to performance and accuracy and the activities of this stage are used to optimize related parameters such as data representation format, scheduling periods, sensor sampling rates, etc.

For this prototyping stage and the next pre-production stage of the HPI CPSLab methodology, we will only present the viewpoints specification. The modeling of root activity subprocesses is straight forward and follows the same principles as that of the simulation stage. 

Like for the simulation stage, we define a viewpoint for each of the two root activities implementing the prototyping stage (Figure~\ref{fig:introduction.methodology}). Therefore for each stage activity, we first present the activity and then define its supporting viewpoint.
\\
\\
\uline{Software in the Loop (SiL)}
\\
\\
For the Software in the Loop (\texttt{SiL}) activity, the tool TargetLink, which is fully integrated into MATLAB Simulink, is used to generate C code from the Simulink behavior model. This allows to seamlessly migrate the functions and control algorithm from continuous behavior of the model level to a discrete approximation implementation in software. Several parameters for code generation can be configured for the characteristics of the desired target platform. Different effects can be analyzed and results can be compared to results obtained during the simulation stage.

The prototyping stage includes two forms of SiL activities. The first form consists of executing the developed software on a desktop computer against a simulator as depicted in Figure~\ref{fig:MMFig7}. The detailed control algorithm from the cyber domain captured by the Matlab/Simulink and AUTOSAR SystemDesk models (SystemModels) are brought together with the physics as present in the sophisticated robot model of the simulator (RobotModel). Therefore, we clearly have a cyber-physical setting. We again have a multi-formalism setting as the control is discrete while the sophisticated robot mode is at least conceptually continuous. Consistency is checked via co-simulation as the software for the robot control runs in parallel with the sophisticated robot simulator.

The second form of SiL also consists of executing the software on a desktop computer but in this case against a real robot remotely controlled as depicted in Figure~\ref{fig:MMFig8}. In this case, real sensor values are read from the robot and real actuators are controlled therefore including other effects such as sensor noise. The same detailed control algorithm from the cyber domain is this time brought together with the physics of the real remotely controlled robot. Consistency is checked via co-execution as the software for the robot control runs in parallel with the remotely controlled robot.
\\
\\
% ============================================
\noindent\uline{Hardware in the Loop (HiL)}
\\
\\
The hardware in the loop (HiL) activity consists of executing the software either on the robot as depicted in Figure~\ref{fig:MMFig8} or on special evaluation boards with debugging and calibration interfaces, which are
similar to the final hardware execution platform. The almost unlimited execution resource of the desktop computer is replaced by the constrained resources of the final platform. Therefore concerns such as resources consumption could be added to this activity.

With its megamodel fragment, this activity ensures that the detailed control algorithm from the cyber domain captured by the Matlab/Simulink model (ControlModel) is brought together with the physics as present in the robot and thus we have clearly a cyber-physical setting. Consistency is checked via executing the software on the robot.

All these SiL and HiL activities actually address similar concerns about the system. The difference resides in the fact that different models at different levels of abstraction (including real hardware) are used. Therefore we define the viewpoints of the following list:
\\
\\
\noindent\uline{Viewpoints}
    \begin{itemize}
         \item Viewpoint: CPSLabSiLSoftwareDesignVP
         \begin{itemize}
            \item hasFramedConcerns: ControlAlgorithm, Stability, Safety, Reliability
            \item hasSystemConstituentElements: Software (Cyber in feature model), ExecutionPlatform (Control in feature model)
            \item hasSupportingMegaModelFragments: CPSLabSiLMMF
         \end{itemize}
        \item Viewpoint: CPSLabHiLSoftwareDesignVP
         \begin{itemize}
            \item hasFramedConcerns: ControlAlgorithm, Stability, Safety, Reliability, Resources Consumption
            \item hasSystemConstituentElements: Software (Cyber in feature model), ExecutionPlatform (Control in feature model)
            \item hasSupportingMegaModelFragments: CPSLabHiLMMF
         \end{itemize}
    \end{itemize}

% ===============================================
\subsection{Modeling Paradigms}
\label{sec:mpm4cps.example.paradigm}

We present here an example the modeling of one of the paradigms employed by the HPI CPSLab, which is Synchronous Data Flow (SDF), following its description in \cite{Amrani2020}. Then we present the modeling of the overall HPI CPSLab model-based development environment employing this paradigm within the MATLAB/Simulink tool captured in its megamodel.

SDF is a special case of the Data Flow paradigm \cite{J:Watson-Gurd:1982}. It specifies a  directed graph of computations nodes (also called \emph{blocks}) exchanging signals representing infinite streams of data. Computation units execute whenever input data becomes available. Such units without input can fire at any time. They can be atomic or composite by encapsulating a subgraph. Arcs connect nodes together and describe how streams of data flow through the computation nodes. Execution consists of accumulating enough samples within the system as produced by blocks without inputs and performing the subsequent nodes computations thus consuming sample data on inputs and concurrently producing outputs. 

The SDF Paradigm \cite{J:Lee-Messerschmitt:1987} is a specialization of Data Flow where all computation nodes are \emph{synchronous}, meaning that each block explicitly defines how many samples are consumed and produced. In their work, \cite{Amrani2020} describe the SDF paradigm as exhibiting the following characteristics:

\begin{itemize}
    \item SignalProperty: \textsf{Signal}s composed of an infinite ordered stream of \textsf{Sample}s are present.
   
   \item DirectedGraphProperty: A \emph{directed} graph with \textsf{Block}s as nodes and \textsf{Arc}s are present. 
   
   \item BlocksPortsProperty: \textsf{Block}s possess \textsf{Port}s that explicitly define how many
   \textsf{Sample}s are used (consumed by \textsf{Input}s, or produced by 
   \textsf{Output}s).

   \item ArcsProperty: \textsf{Arc}s connect \textsf{Port}s and instantaneously transmit \textsf{Signal}s. Note that a \textsf{Port} may be plugged to several \textsf{Arc}s but \textsf{shortcuts} are prohibited.
   \textsf \textsf{Arc}s are forbidden to connect as source and target \textsf{Port}s of the same \textsf{Type}.
   
   \item MemoryFullProperty: A \textsf{MemoryFull} \textsf{Block} should always define an extra \textsf{Port} corresponding to initial conditions. 
\end{itemize}

Following this, we define an engineering paradigm to represent SDF as follows:
\\
\\
\noindent\uline{Engineering Paradigms}
\begin{itemize}
    \item ModelingEngineeringParadigm: SDFParadigm
    \begin{itemize}
        \item hasCharacteristics: SDFParadigmCharacteristics
        \begin{itemize}
            \item hasProperties: SignalProperty, DirectedGraphProperty, BlocksPortsProperty, ArcsProperty, MemoryFullProperty
        \end{itemize}
    \end{itemize}
\end{itemize}

There are several ways such properties could be specified. If all languages and their semantics expressed as semantic domains are encoded using the same technical space such as Ecore metamodels, then these properties could be encoded as graph patterns using tools such as Henshin\footnote{\url{https://www.eclipse.org/henshin/}} or SDM\footnote{\url{https://www.hpi.uni-potsdam.de/giese/public/mdelab/mdelab-projects/story-diagram-tools/}}.

It should be noted that the aforementioned Catalog of Formalisms, Modeling Languages and Tools already declares SDF as being a formalism and not a paradigm. Besides, several modeling languages of the catalog such as Simulink are declared as being based on SDF. Therefore, the question of whether SDF should be classified as a formalism or a paradigm remains. A deeper study of the catalog's formalisms could help answer that question.

Next, we model the HPI CPSLab model-based engineering environment, which uses the CPSLabMM megamodel presented in the HPI CPSLab example of Chapter~\ref{ch:foundations:MPM-Ontology} and the CPSLabProcess development process defined in the previous section:
\\
\\
\noindent\uline{Engineering Environment}
\begin{itemize}
\item ModelBasedEngineeringEnv: CPSLabEngineeringEnv
    \begin{itemize}
        \item hasModelingArtifacts: CPSLabMM, CPSLabProcess
        \item isBasedOnParadigms: SDFParadigm
    \end{itemize}
\end{itemize}

It should be noted that the \uidxp{isBasedOnParadigms} property at the engineering environment level is derived from the same property of Simulink language captured in the mega model. This can be determined from the SDFParadigm and its properties evaluated onver the language and its semantics.
%\TODONOTE{ HG: viewpoint: suitable system behavior, concern: robust overall control }

%\TODONOTE{ HG: we have similar concerns that are repeatedly checked with different degrees of detail. Do we need different viewpoint names? }


% ========================================

% ============================================
%\subsubsection{Use of MPM4CPS Ontology}\label{subsubsec:cpslab-mpm4cps-use}
%
%\TODONOTE{ HG: Which MPM4CPS concept are required to describe the linkage between the MegaModelFragments with its models  from the MPM ontology and the CPS concepts from the CPS ontology?}
\LATER[advanced scenarios]{

% ============================================
\subsubsection{Advanced Scenarios}
%

\begin{enumerate}
    \item Vertical enrichment of functional models (consistency manually)
\item Horizontal integration of functional and plant models
\item Horizontal integration of multiple functional models, an architecture model, and a plant model
\item Vertical enrichment of multiple functional models, an architecture model, and a plant model (to realize functions while meeting resource constraints)
\end{enumerate}

{\bf The Challenge of Model-Based Integration for Cyber-Physical Systems}
\begin{enumerate}
    \item Vertical refinement of functional models (consistency manually)
\item Horizontal integration of functional and plant models
\item Horizontal integration of multiple functional models, an architecture model, and a plant model
\item Vertical refinement of functional models (to realize functions while meeting resource constraints)
\end{enumerate}

KKKKKKKKKKKKK


\begin{figure}[!htb]
\centering
\includegraphics[scale=0.33]{figures/mm-hpi12.pdf}
\caption{Vertical Enrichment and  Transformation}
\label{fig:MMFig11}
\end{figure}

{\bf Vertical Enrichment and  Transformation} Figure~\ref{fig:MMFig11}
\begin{enumerate}
    \item Vertical enrichment of functional models and architecture
\item Floating-Point 2 Fix-Point to reduce resource demands models (consistency manually)
\item Fix-Point data-flow model 2 C-code models (consistency automatically)
\item Autosar 2 C-code models (consistency automatically)
\end{enumerate}

\begin{figure}[!htb]
\centering
\includegraphics[scale=0.33]{figures/mm-hpi14.pdf}
\caption{Model in the Loop (MiL)}
\label{fig:MMFig12}
\end{figure}

{\bf Model in the Loop (MiL)} Figure~\ref{fig:MMFig12}

\begin{enumerate}
    \item Layer: Abstract Control Algorithm + Idealized Plant
\item Domain: Control/Software + Physics
\item Multi-Paradigm: Yes, if control is discrete 
\item Cyber-Physical system: Yes, as control is cyber world and plant is from the physical world
\item Integration: Decomposition and Composition + parallel development; semantics-level
\end{enumerate}

\begin{figure}[!htb]
\centering
\includegraphics[scale=0.33]{figures/mm-hpi15.pdf}
\caption{Scenario: Complex Horizontal Integration}
\label{fig:MMFig13}
\end{figure}
\newpage
{\bf Scenario: Complex Horizontal Integration} Figure~\ref{fig:MMFig13}

\begin{enumerate}
    \item Horizontal combination of multiple functional models by the architecture via the generated software (integration by composition for functions, integration by abstraction for OS)
\item Downwards propagation can be expected, but must be managed
\item Upwards propagation is usually forbidden (suppressed)
\item Horizontal propagation is therefore also forbidden (suppressed)
    
\end{enumerate}


\begin{figure}[!htb]
\centering
\includegraphics[scale=0.33]{figures/mm-hpi16.pdf}
\caption{Scenario: More Complex Horizontal Integration}
\label{fig:MMFig14}
\end{figure}

{\bf Scenario: More Complex Horizontal Integration } Figure~\ref{fig:MMFig14}

\begin{enumerate}
    \item Horizontal combination of multiple specific structures (Autosar: software; VHDL: hardware, Matlab/Modelica: plant) via a generic structure (SysML) 
\item Downwards propagation can be expected, but must be managed
\item Upwards propagation is usually forbidden (suppressed)
\item Horizontal propagation is therefore also forbidden (suppressed)
\item Vertical decomposition via a generic system structure (SysML) containing multiple specific structures (Matlab: control; Autosar: software; VHDL: hardware, Matlab/Modelica: plant; ...)
\item Consistency between models and in the models interact, which may lead to transitive propagation/conflicts
    
\end{enumerate}

}

\LATER[need for integration]{

% =========================================
\subsection{OPTIONAL?}

KKKKKKK

In order to discuss the role of MPM for CPS as present in the case study, we at first review the inherent integration needs underlying the development of embedded real-time systems and cyber-physical systems in particular based on the finding of \cite{GieseNNS2011}.

% ============================================
\subsubsection{Need for Integration}
%
As outline in \cite{GieseNNS2011} in more detail, the integration of separate parts of a system under development is tackled by a combination of (a) composition, (b) abstraction, and (c) consistency. As depicted in Figure~\ref{fig:MMFig1}, 

.

\begin{figure}[!htb]
\centering
%\includegraphics[scale=0.33]{figures/MM-Figure-1.pdf}
\includegraphics[scale=0.33]{figures/mm-hpi1.pdf}
\caption{Integration: 
When and  How (from~\cite{GieseNNS2011})}
\label{fig:MMFig1}
\end{figure}



% =========================================
\subsubsection{Enrichment}

KKKKKKKKK

\begin{figure}[!htb]
\centering
\includegraphics[scale=0.33]{figures/mm-hpi19.pdf}
\caption{Example for Approximation: Control}
\label{fig:MMFig15}
\end{figure}

{\bf Control:}

\begin{enumerate}
    \item Design an idealized control algorithm that assumes a continuous behavior in form of a differential equation (infinite fast; no discretization errors; $\ldots$)
\item Analyze that the idealized control algorithm provides the required guarantees (stability)
\item The later implemented control software and its timing is then tuned until it behaves as required (which is usually possible!)
\end{enumerate}


{\bf Approximation:}

\begin{enumerate}
    \item Ignore later details via idealization
\item Do not preserve relevant properties, but assumes that later considered details can be somehow handled
\item Optimistic approach: a solution for the problems raised by the later considered details will likely be found

\end{enumerate}



\begin{figure}[!htb]
\centering
\includegraphics[scale=0.33]{figures/mm-hpi20.pdf}
\caption{Example for Refinement: Protocols}
\label{fig:MMFig16}
\end{figure}

{\bf Protocol:}

\begin{enumerate}
    \item Design an abstract model of a protocol that captures all possible message delays 
\item Verify that the abstract model guarantees the properties required for the protocol
\item The concrete protocol with specific time delays for messages will then be a refinement and thus also guarantees the required properties.
\end{enumerate}

{\bf Refinement:}

\begin{enumerate}
    \item Abstract from later details in a pessimistic manner
\item Preserve relevant properties
\item Pessimistic approach: 
exclude errors in later stages to be on the safe side
    
\end{enumerate}




\begin{figure}[!htb]
\centering
\includegraphics[scale=0.33]{figures/mm-hpi21.pdf}
\caption{Refinement vs. Approximation}
\label{fig:MMFig17}
\end{figure}

{\bf Approximation:}

\begin{enumerate}
    \item Ignore later details via idealization
\item Do not preserve relevant properties, but assumes that later considered details can be somehow handled
\item Optimistic approach: a solution for the problems raised by the later considered details will likely be found
    
\end{enumerate}

{\bf Refinement:}

\begin{enumerate}
    \item Abstract from later details in a pessimistic manner
\item Preserve relevant properties
\item Pessimistic approach: 
exclude errors in later stages to be on the safe side
\end{enumerate}


}

% ===============================================
\subsection{Summary}
%
We have demonstrated that the framework introduced in this report is 
%
suitable to capture the needs concerning this case study for CPS in form of the extensions of the CPS ontology discussed in  Section~\ref{subsec:cpslab-cps},
%
covering the needs concerning this case study for MPM in form of the extensions of the MPM ontology and the catalog discussed in  Section~\ref{subsec:cpslab-mpm}, and
%
captures the cyber-physical aspects of the development quite well as outlined in  Section~\ref{subsec:cpslab-mpm4cps}.

