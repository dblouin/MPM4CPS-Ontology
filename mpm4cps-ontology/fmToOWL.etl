pre {
	"Running fmToOWL transformation".println();
	var ont : new owl!Ontology;
	var sharedOnt : new owl!Import;	
	var sharedClasses = new List;
	
	// Header settings
	ont.base = "http://mpm4cps.eu/ontology/cps";
	ont.ontologyIRI = "http://mpm4cps.eu/ontology/cps";
	
	// Prefixes
	addPrefix("", "http://mpm4cps.eu/ontology/cps");
	addPrefix("owl", "http://www.w3.org/2002/07/owl#");
	addPrefix("rdf", "http://www.w3.org/1999/02/22-rdf-syntax-ns#");
	addPrefix("xml", "http://www.w3.org/XML/1998/namespace");
	addPrefix("xsd", "http://www.w3.org/2001/XMLSchema#");
	addPrefix("rdfs", "http://www.w3.org/2000/01/rdf-schema#");
	
	
	//import shared ontology and prepare a list of its classes
	sharedOnt.value = "http://mpm4cps.eu/ontology/shared";
	ont.Import.add(sharedOnt);

	var root : new owl!Class;
	var owlDeclaration : new owl!Declaration;
	
	root.iri = generateOwlClassIRI("CpsDC");
	owlDeclaration.class = root;
	ont.declaration.add(owlDeclaration);
	ont.annotationAssertion.add(createAuthor(root.iri, "FeatureModel"));
	
	
	for (class in shared!Class) {
	   sharedClasses.add(class.iri);
	   if (class.iri = "#DomainConcept"){
          root.ontHierarchyShared("DomainConcept");	
	   }
	}
}

post {
	"Feature model to OWL transformation finished.".println();
}

/**************************/
/********* RULES **********/
/**************************/

// The following two rules transform the feature model instances to owl classes
rule featureTypeToClass
	transform feature : fm!FeatureType
	to owlDeclaration : owl!Declaration {
	guard : not feature.isDisabled() and not 
	        feature.isIndividual ()
		// Create class
		var owlClass : new owl!Class;
		owlClass.iri = generateOwlClassIRI(feature.name);
		owlDeclaration.class = owlClass;
		ont.declaration.add(owlDeclaration);

		// Create description (if any)
		if (feature.description.isDefined()) {
			ont.annotationAssertion.add(createDescription(owlClass.iri, feature.description));
			ont.annotationAssertion.add(createAuthor(owlClass.iri, "FeatureModel"));
		}		
	}
	

rule branchTypeToClass
	transform branch : fm!BranchType
	to owlDeclaration : owl!Declaration {
	guard : not branch.isDisabled ()

		var owlClass : new owl!Class;
		owlClass.iri = generateOwlClassIRI(branch.name);
		owlDeclaration.class = owlClass;
		ont.declaration.add(owlDeclaration);
		// Create description (if any)
		if (branch.description.isDefined()) {
			ont.annotationAssertion.add(createDescription(owlClass.iri, branch.description));
			ont.annotationAssertion.add(createAuthor(owlClass.iri, "FeatureModel"));
		}
		
		var subClasses : List = branch.hasSubclasses();
		// subfeatures and subbranches should be subclasses of the branch
        if (subClasses.notEmpty){
		   for (subClass in subClasses){	
		      if (subClass.equivalent().isDefined ()){
		         subClass.equivalent().class.ontHierarchy(owlClass);
		      }
		   }
		} else {
		// subfeatures should be subclasses of the CpsDC
	       for (feature in branch.feature) {
		      if (feature.equivalent().isDefined ()){
		         feature.equivalent().class.ontHierarchy(root);
		      }
	       }
	    }
	if (not branch.isSubclass ()) {
       owlClass.ontHierarchy(root);
    }
}

// Add object properties to the ontology (used for relationships between classes)
rule branchTypeToDeclareObjectProperties
	transform branch : fm!BranchType
	to owlDeclaration : owl!Declaration, owlOP : owl!ObjectProperty {
	guard : not branch.isDisabled ()
		owlOP.iri = branch.generateOwlObjectPropertyIRI();
		owlDeclaration.objectProperty = owlOP;
		ont.declaration.add(owlDeclaration);
	}

rule featureTypeToDeclareObjectProperties
	transform feature : fm!FeatureType
	to owlDeclaration : owl!Declaration, owlOP : owl!ObjectProperty {
	guard : not feature.isDisabled () and not feature.isIndividual ()
		owlOP.iri = feature.generateOwlObjectPropertyIRI();
		owlDeclaration.objectProperty = owlOP;
		ont.declaration.add(owlDeclaration);	
	}
	
rule branchTypeToObjectPropertyRange
	transform branch : fm!BranchType
	to owlObjectPropertyRange : owl!ObjectPropertyRange, 
	owlOP : owl!ObjectProperty, 
	owlClass: owl!Class {
	guard : not branch.isDisabled ()
		owlOP.iri = branch.generateOwlObjectPropertyIRI();
		owlObjectPropertyRange.objectProperty = owlOP;
		owlClass.iri = generateOwlClassIRI(branch.name);
		owlObjectPropertyRange.class = owlClass;
		ont.objectPropertyRange.add( owlObjectPropertyRange );
	}

rule featureTypeToObjectPropertyRange
	transform feature : fm!FeatureType
	to owlObjectPropertyRange : owl!ObjectPropertyRange,
	   owlOP : owl!ObjectProperty, owlClass: owl!Class {
    guard : not feature.isDisabled () and not feature.isIndividual ()
		owlOP.iri = feature.generateOwlObjectPropertyIRI();
		owlObjectPropertyRange.objectProperty = owlOP;
		owlClass.iri = generateOwlClassIRI(feature.name);
		owlObjectPropertyRange.class = owlClass;
		ont.objectPropertyRange.add( owlObjectPropertyRange );
	}


// Add object property relationships to the ontology
rule andBranchTypeToSubclassOf
	transform branch : fm!BranchType
	to owlSubClassOf : owl!SubClassOf, 
	   owlClass : owl!Class, 
	   owlObjectIntersectionOf : owl!ObjectIntersectionOf {
	guard : branch.isAndBranch() and branch.hasFeatures( true ) and not branch.isDisabled ()

	owlClass.iri = generateOwlClassIRI(branch.name);
	owlSubClassOf.class.add(owlClass);
	owlSubClassOf.objectIntersectionOf = owlObjectIntersectionOf;
	ont.subclassof.add( owlSubClassOf );
	
	for ( subBranch in branch.And ) {
		subBranch.addSomeValueFromFeature( owlObjectIntersectionOf, true );
	}
	
	for ( subBranch in branch.alt ) {
		subBranch.addSomeValueFromFeature( owlObjectIntersectionOf, true );
	}

	for ( subBranch in branch.Or ) {
		subBranch.addSomeValueFromFeature( owlObjectIntersectionOf, true );
	}

	for ( feature in branch.feature ) {
		feature.addSomeValueFromFeature( owlObjectIntersectionOf, true );
	}
}

rule orBranchTypeToSubclassOf
	transform branch : fm!BranchType
	to owlSubClassOf : owl!SubClassOf, 
	   owlClass : owl!Class, 
	   owlObjectUnionOf : owl!ObjectUnionOf {
	guard : branch.isOrBranch() or branch.isAltBranch() 
	and branch.hasFeatures( false ) 
	and not branch.isDisabled () and not branch.hasIndividual ()

	owlClass.iri = generateOwlClassIRI(branch.name);
	owlSubClassOf.class.add(owlClass);
	owlSubClassOf.objectUnionOf = owlObjectUnionOf;
	ont.subclassof.add( owlSubClassOf );
	
	for ( subBranch in branch.And ) {
		subBranch.addSomeValueFromFeature( owlObjectUnionOf );
	}
	
	for ( subBranch in branch.alt ) {
		subBranch.addSomeValueFromFeature( owlObjectUnionOf );
	}

	for ( subBranch in branch.Or ) {
		subBranch.addSomeValueFromFeature( owlObjectUnionOf );
	}

	for ( feature in branch.feature ) {
		feature.addSomeValueFromFeature( owlObjectUnionOf );
	}
}

rule altBranchTypeToSubclassOf
	transform branch : fm!BranchType
	to owlSubClassOf : owl!SubClassOf, owlClass : owl!Class, owlObjectComplementOf : owl!ObjectComplementOf, owlObjectUnionOf : owl!ObjectUnionOf {
	guard : branch.isAltBranch() and branch.hasFeatures( false ) and not branch.isDisabled () and not branch.hasIndividual ()

	owlClass.iri = generateOwlClassIRI(branch.name);
	owlSubClassOf.class.add(owlClass);
	owlSubClassOf.objectComplementOf = owlObjectComplementOf;
	owlObjectComplementOf.objectUnionOf = owlObjectUnionOf;
	ont.subclassof.add( owlSubClassOf );
	
	for ( subBranch in branch.And ) {
		branch.addDisjointTwoByTwoFeatures( owlObjectUnionOf, subBranch );
	}
	
	for ( subBranch in branch.alt ) {
		branch.addDisjointTwoByTwoFeatures( owlObjectUnionOf, subBranch );
	}

	for ( subBranch in branch.Or ) {
		branch.addDisjointTwoByTwoFeatures( owlObjectUnionOf, subBranch );
	}

	for ( feature in branch.feature ) {
		branch.addDisjointTwoByTwoFeatures( owlObjectUnionOf, feature );
	}
}



/**************************/
/******* OPERATIONS *******/
/**************************/
operation fm!BranchType convert() {
	if (self.hidden) {
		return false;
	}
	
	if ( self.eContainer.isDefined() ) {
		return self.eContainer.convert ();
	}
	
	return true;
}

operation fm!FeatureType convert() {
	if ( self.hidden ) {
		return false;
	}
	
	if ( self.eContainer.isDefined() ) {
		return self.eContainer.convert ();
	}
	
	return true;
}

operation fm!StructType convert() {
	return true;
}

operation fm!FeatureModelType convert() {
	return true;
}

operation fm!BranchType hasFeatures( checkMandatory : Boolean ) {
	for ( subBranch in self.And ) {
		if ( not subBranch.isHidden() and ( not checkMandatory or subBranch.isMandatory() ) ) {
			return true;
		}
	}
	
	for ( subBranch in self.alt ) {
		if ( not subBranch.isHidden() and ( not checkMandatory or subBranch.isMandatory() ) ) {
			return true;
		}
	}

	for ( subBranch in self.Or ) {
		if ( not subBranch.isHidden() and ( not checkMandatory or subBranch.isMandatory() ) ) {
			return true;
		}
	}

	for ( feature in self.feature ) {
		if ( not feature.isHidden() and ( not checkMandatory or feature.isMandatory() ) ) {
			return true;
		}
	}
	
	return false;
}

operation fm!BranchType addSomeValueFromFeature(owlObjectIntersectionOf : owl!ObjectIntersectionOf,
													checkMandatory : Boolean ) {
	if ( not self.isHidden() and ( not checkMandatory or self.isMandatory() ) ) {
		var owlObjectSomeValuesFrom : new owl!ObjectSomeValuesFrom;
		var owlOP : new owl!ObjectProperty;
		owlOP.iri = self.generateOwlObjectPropertyIRI();
		owlObjectSomeValuesFrom.objectProperty = owlOP;
		var owlClassRange : new owl!Class;
		owlClassRange.iri = generateOwlClassIRI(self.name);
		owlObjectSomeValuesFrom.class = owlClassRange;
		owlObjectIntersectionOf.objectSomeValuesFrom.add( owlObjectSomeValuesFrom );
	}
}

operation fm!FeatureType addSomeValueFromFeature( 	
    owlObjectIntersectionOf : owl!ObjectIntersectionOf,
    checkMandatory : Boolean ) {
	if (not self.isHidden() and 
	    (not checkMandatory or self.isMandatory()) 
	    ) {
		var owlObjectSomeValuesFrom : new owl!ObjectSomeValuesFrom;
		var owlOP : new owl!ObjectProperty;
		owlOP.iri = self.generateOwlObjectPropertyIRI();
		owlObjectSomeValuesFrom.objectProperty = owlOP;
		var owlClassRange : new owl!Class;
		owlClassRange.iri = generateOwlClassIRI(self.name);
		owlObjectSomeValuesFrom.class = owlClassRange;
		owlObjectIntersectionOf.objectSomeValuesFrom.add( owlObjectSomeValuesFrom );
	}
}

operation fm!BranchType addSomeValueFromFeature( owlObjectUnionOf : owl!ObjectUnionOf ) {
	if ( not self.isHidden() ) {
		var owlObjectSomeValuesFrom : new owl!ObjectSomeValuesFrom;
		var owlOP : new owl!ObjectProperty;
		owlOP.iri = self.generateOwlObjectPropertyIRI();
		owlObjectSomeValuesFrom.objectProperty = owlOP;
		
		var owlClassRange : new owl!Class;
		owlClassRange.iri = generateOwlClassIRI(self.name);
		owlObjectSomeValuesFrom.class = owlClassRange;
		owlObjectUnionOf.objectSomeValuesFrom.add( owlObjectSomeValuesFrom );
	}
}

operation fm!FeatureType addSomeValueFromFeature( owlObjectUnionOf : owl!ObjectUnionOf ) {
	if (not self.isHidden() 
	) {
		var owlObjectSomeValuesFrom : new owl!ObjectSomeValuesFrom;
		var owlOP : new owl!ObjectProperty;
		owlOP.iri = self.generateOwlObjectPropertyIRI();
		owlObjectSomeValuesFrom.objectProperty = owlOP;
		var owlClassRange : new owl!Class;
		owlClassRange.iri = generateOwlClassIRI(self.name);
		owlObjectSomeValuesFrom.class = owlClassRange;
		owlObjectUnionOf.objectSomeValuesFrom.add( owlObjectSomeValuesFrom );
	}
}

operation fm!BranchType addDisjointTwoByTwoFeatures( 	owlObjectUnionOf : owl!ObjectUnionOf,
														branch : fm!BranchType ) {
	for ( subBranch in self.And ) {
		if ( branch <> subBranch and not subBranch.isHidden() ) {
			var owlObjectIntersectionOf : new owl!ObjectIntersectionOf;
			owlObjectUnionOf.objectIntersectionOf.add( owlObjectIntersectionOf );
			branch.addSomeValueFromFeature( owlObjectIntersectionOf, false );
			subBranch.addSomeValueFromFeature( owlObjectIntersectionOf, false );
		}
	}
	
	for ( subBranch in self.alt ) {
		if ( branch <> subBranch and not subBranch.isHidden() ) {
			var owlObjectIntersectionOf : new owl!ObjectIntersectionOf;
			owlObjectUnionOf.objectIntersectionOf.add( owlObjectIntersectionOf );
			branch.addSomeValueFromFeature( owlObjectIntersectionOf, false );
			subBranch.addSomeValueFromFeature( owlObjectIntersectionOf, false );
		}
	}

	for ( subBranch in self.Or ) {
		if ( branch <> subBranch and not subBranch.isHidden() ) {
			var owlObjectIntersectionOf : new owl!ObjectIntersectionOf;
			owlObjectUnionOf.objectIntersectionOf.add( owlObjectIntersectionOf );
			branch.addSomeValueFromFeature( owlObjectIntersectionOf, false );
			subBranch.addSomeValueFromFeature( owlObjectIntersectionOf, false );
		}
	}

	for ( subFeature in self.feature ) {
		if ( not subFeature.isHidden() ) {
			var owlObjectIntersectionOf : new owl!ObjectIntersectionOf;
			owlObjectUnionOf.objectIntersectionOf.add( owlObjectIntersectionOf );
			branch.addSomeValueFromFeature( owlObjectIntersectionOf, false );
			subFeature.addSomeValueFromFeature( owlObjectIntersectionOf, false );
		}
	}
}

operation fm!BranchType addDisjointTwoByTwoFeatures( 	owlObjectUnionOf : owl!ObjectUnionOf,
														feature : fm!FeatureType ) {
	for ( subBranch in self.And ) {
		if ( not subBranch.isHidden() ) {
			var owlObjectIntersectionOf : new owl!ObjectIntersectionOf;
			owlObjectUnionOf.objectIntersectionOf.add( owlObjectIntersectionOf );
			feature.addSomeValueFromFeature( owlObjectIntersectionOf, false );
			subBranch.addSomeValueFromFeature( owlObjectIntersectionOf, false );
		}
	}
	
	for ( subBranch in self.alt ) {
		if ( not subBranch.isHidden() ) {
			var owlObjectIntersectionOf : new owl!ObjectIntersectionOf;
			owlObjectUnionOf.objectIntersectionOf.add( owlObjectIntersectionOf );
			feature.addSomeValueFromFeature( owlObjectIntersectionOf, false );
			subBranch.addSomeValueFromFeature( owlObjectIntersectionOf, false );
		}
	}

	for ( subBranch in self.Or ) {
		if ( not subBranch.isHidden() ) {
			var owlObjectIntersectionOf : new owl!ObjectIntersectionOf;
			owlObjectUnionOf.objectIntersectionOf.add( owlObjectIntersectionOf );
			feature.addSomeValueFromFeature( owlObjectIntersectionOf, false );
			subBranch.addSomeValueFromFeature( owlObjectIntersectionOf, false );
		}
	}

	for ( subFeature in self.feature ) {
		if ( feature <> subFeature and not subFeature.isHidden() ) {
			var owlObjectIntersectionOf : new owl!ObjectIntersectionOf;
			owlObjectUnionOf.objectIntersectionOf.add( owlObjectIntersectionOf );
			feature.addSomeValueFromFeature( owlObjectIntersectionOf, false );
			subFeature.addSomeValueFromFeature( owlObjectIntersectionOf, false );
		}
	}
}

operation fm!BranchType isMandatory() : Boolean {
	if ( self.mandatory.isDefined() ) {
		return self.mandatory.asBoolean();
	}
	
	return false;
}

operation fm!BranchType isAndBranch() :  Boolean {
	return self.isBranchOf( 'and' );
}

operation fm!BranchType isOrBranch() :  Boolean {
	return self.isBranchOf( 'or' );
}

operation fm!BranchType isAltBranch() :  Boolean {
	return self.isBranchOf( 'alt' );
}

operation fm!BranchType isBranchOf(	type : String ) :  Boolean {
	
	return self.eContainingFeature().name = type;
}

operation addPrefix(prefixName : String, prefixIRI : String) {
	var prefix = new owl!Prefix;
	prefix.name = prefixName;
	prefix.iri = prefixIRI;
	ont.Prefix.add(prefix);
}

operation generateOwlClassIRI(fmName : String) : String {
	return generateOwlClassIRI( '', fmName );
}

operation generateOwlClassIRI(	prefix: String,
								fmName : String) : String {
	var refactoredfmName : String;
	var splited = new List;
	splited = fmName.split("\\s+");
	if (splited.size() > 1) {
		for (s in splited) {
			refactoredfmName += s.firstToUpperCase();
		}
		fmName = refactoredfmName;
	}
	if (sharedClasses.contains("#"+ prefix + fmName)) {
			return sharedOnt.value + "#" + prefix + fmName;
	}
	else {
			return "#" + prefix + fmName.legalName();
	}

}

operation createDescription (classIRI : String, description : String) : owl!AnnotationAssertion {
	var owlAnnotation : new owl!AnnotationAssertion;
	
	// Create AnnotationProperty
	var annotationProp : new owl!AnnotationProperty;
	annotationProp.abbreviatedIRI = "rdfs:comment";
	owlAnnotation.annotationProperty = annotationProp;
	
	// Create IRI
	var iri : new owl!IRI;
	iri.value = classIRI;
	owlAnnotation.iri = iri;
	
	// Create Literal
	var literal : new owl!Literal;
	literal.datatypeIRI = "http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral";
	literal.value = description;
	owlAnnotation.literal = literal;
	
	return owlAnnotation;
}

operation createAuthor (classIRI : String, author : String) : owl!AnnotationAssertion {
	var owlAnnotation : new owl!AnnotationAssertion;
	
	// Create AnnotationProperty
	var annotationProp : new owl!AnnotationProperty;
	annotationProp.iri = "#mpm4cps:author";
	owlAnnotation.annotationProperty = annotationProp;
	
	// Create IRI
	var iri : new owl!IRI;
	iri.value = classIRI;
	owlAnnotation.iri = iri;
	
	// Create Literal
	var literal : new owl!Literal;
	literal.datatypeIRI = "http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral";
	literal.value = author;
	owlAnnotation.literal = literal;
	
	return owlAnnotation;
}

operation fm!BranchType generateOwlObjectPropertyIRI() : String {
		return "#has" + self.name.legalName();
}

operation fm!FeatureType generateOwlObjectPropertyIRI() : String {
	return "#has" + self.name.legalName();
}

operation String legalName() : String {
	return self.replaceall( ' ', '' );
}

operation deleteFeature (branch : fm!BranchType) {
	for (subBranch in branch.alt) {
		for (feature in subBranch.feature) {
			delete feature.equivalent();
		}
	}
	
	for (subBranch in branch.Or) {
		for (feature in subBranch.feature) {
			delete feature.equivalent();
		}
	}
	
	for (subBranch in branch.And) {
		for (feature in subBranch.feature) {
			delete feature.equivalent();
		}
	}
}


operation searchForBranches (branch : fm!BranchType) {
	// Alternative branches
	for (subBranch in branch.alt) {
			var owlSubClassOf : new owl!SubClassOf;
			var owlClass : new owl!Class;
			var owlOP : new owl!ObjectProperty;
			addAltObjProp(owlSubClassOf, owlClass, owlOP, subBranch);
			
			if ( (not subBranch.And.isEmpty()) or (not subBranch.Or.isEmpty()) or (not subBranch.alt.isEmpty()) ) {
				searchForBranches(subBranch);
			}
		//}
	}
	
	// Mandatory branches
	for (subBranch in branch.And) {
			var owlSubClassOf : new owl!SubClassOf;
			var owlClass : new owl!Class;
			var owlOP : new owl!ObjectProperty;
			addAndObjProp(owlSubClassOf, owlClass, owlOP, subBranch, false);
			
			if ( (not subBranch.And.isEmpty()) or (not subBranch.Or.isEmpty()) or (not subBranch.alt.isEmpty()) ) {
				searchForBranches(subBranch);
			}
		//}
	}

	// Or branches
	for (subBranch in branch.Or) {
			var owlSubClassOf : new owl!SubClassOf;
			var owlClass : new owl!Class;
			var owlOP : new owl!ObjectProperty;
			addOrObjProp(owlSubClassOf, owlClass, owlOP, subBranch);
			
			if ( (not subBranch.And.isEmpty()) or (not subBranch.Or.isEmpty()) or (not subBranch.alt.isEmpty()) ) {
				searchForBranches(subBranch);
			}
	}
}

// Add alternative object property between ontology classes
/*operation addAltObjProp(owlSubClassOf : owl!SubClassOf, owlClass : owl!Class, owlOP : owl!ObjectProperty, branch : fm!BranchType) {
	// Add class
	owlClass.iri = generateOwlClassIRI(branch.name);
	owlSubClassOf.class.add(owlClass);

	owlOP.iri = branch.generateOwlObjectPropertyIRI();
	
	var owlObjectAllValuesFrom : new owl!ObjectAllValuesFrom;
	var owlObjectUnionOf : new owl!ObjectUnionOf;
	
	owlObjectAllValuesFrom.objectProperty = owlOP;
	
	for (feature in branch.feature) {
		// Create childs for every branch in the feature model
		var owlChildClass : new owl!Class;				
		owlChildClass.iri = feature.equivalent().class.iri;	
			
		// Add the child elements to the ObjectUnionOf MM class
		owlObjectUnionOf.class.add(owlChildClass);
	}
	
	for (subBranch in branch.And) {
		// Create childs for every branch in the feature model
		var owlChildClass : new owl!Class;				
		owlChildClass.iri = subBranch.equivalent().class.iri;	
		// Add the child elements to the ObjectUnionOf MM class
		owlObjectUnionOf.class.add(owlChildClass);
	}
	
	for (subBranch in branch.Or) {
		// Create childs for every branch in the feature model
		var owlChildClass : new owl!Class;		
		owlChildClass.iri = subBranch.Dua Lipa - IDGAFequivalent().class.iri;	
		// Add the child elements to the ObjectUnionOf MM class
		owlObjectUnionOf.class.add(owlChildClass);
	}
	
	for (subBranch in branch.alt) {
		// Create childs for every branch in the feature model
		var owlChildClass : new owl!Class;				
		owlChildClass.iri = subBranch.equivalent().class.iri;	
		// Add the child elements to the ObjectUnionOf MM class
		owlObjectUnionOf.class.add(owlChildClass);
	}
	
	// Add the ObjectUnionOf element to the ObjectAllValuesFrom MM class
	owlObjectAllValuesFrom.objectUnionOf = owlObjectUnionOf;	
	owlSubClassOf.objectAllValuesFrom = owlObjectAllValuesFrom;
	ont.subclassof.add(owlSubClassOf);
}


// Add mandatory object property between ontology classes
operation addAndObjProp(owlSubClassOf : owl!SubClassOf, owlClass : owl!Class, owlOP : owl!ObjectProperty, branch : fm!BranchType, overruleMandatory : Boolean) {
	// Add class
	owlClass.iri = generateOwlClassIRI(branch.name);
	owlSubClassOf.class.add(owlClass);
	
	var owlObjectSomeValuesFrom : new owl!ObjectSomeValuesFrom;
	var owlObjectIntersectionOfSome : new owl!ObjectIntersectionOf;
	owlOP.iri = branch.generateOwlObjectPropertyIRI();
	owlObjectSomeValuesFrom.objectProperty = owlOP;
	
	var owlClassMin : new owl!Class;
	owlClassMin.iri = generateOwlClassIRI(branch.name);
	var owlSubClassOfMin : new owl!SubClassOf;
	owlSubClassOfMin.class.add(owlClassMin);
	var owlOPMin : new owl!ObjectProperty;
	var owlObjectMinCardinality : new owl!ObjectMinCardinality;
	var owlObjectIntersectionOfMin : new owl!ObjectIntersectionOf;
	owlOPMin.iri = branch.generateOwlObjectPropertyIRI();
	owlObjectMinCardinality.objectProperty = owlOPMin;
	
	for (feature in branch.feature) {
		// Create childs for every branch in the feature model
		var owlChildClass : new owl!Class;				
		owlChildClass.iri = feature.equivalent().class.iri;	
		if ((overruleMandatory == true) or (feature.mandatory == true)) {
			// Add the child elements to the ObjectIntersectionOf MM class
			owlObjectIntersectionOfSome.class.add(owlChildClass);
		}
		else {
			// Add the child elements to the ObjectIntersectionOf MM class
			owlObjectIntersectionOfMin.class.add(owlChildClass);
		}
	}
	
	for (subBranch in branch.And) {
		if ( isSubclass( subBranch.name ) ) {
//		if (not subBranch.name.endsWith('*')) {
			// Create childs for every branch in the feature model
			var owlChildClass : new owl!Class;				
			owlChildClass.iri = subBranch.equivalent().class.iri;
			// Add the child elements to the ObjectIntersectionOf MM class
			owlObjectIntersectionOfSome.class.add(owlChildClass);
		}
	}
	
	for (subBranch in branch.Or) {
		if ( isSubclass( subBranch.name ) ) {
//		if (not subBranch.name.endsWith('*')) {
			// Create childs for every branch in the feature model
			var owlChildClass : new owl!Class;				
			owlChildClass.iri = subBranch.equivalent().class.iri;
			// Add the child elements to the ObjectIntersectionOf MM class
			owlObjectIntersectionOfSome.class.add(owlChildClass);
		}		
	}
	
	for (subBranch in branch.alt) {
		if ( isSubclass( subBranch.name ) ) {
//		if (not subBranch.name.endsWith('*')) {
			// Create childs for every branch in the feature model
			var owlChildClass : new owl!Class;				
			owlChildClass.iri = subBranch.equivalent().class.iri;
			// Add the child elements to the ObjectIntersectionOf MM class
			owlObjectIntersectionOfSome.class.add(owlChildClass);
		}		
	}
	
	// Add the ObjectIntersectionOf element to the ObjectSomeValuesFrom MM class
	if (not owlObjectIntersectionOfSome.class.isEmpty()) {
		owlObjectSomeValuesFrom.objectIntersectionOf = owlObjectIntersectionOfSome;	
		owlSubClassOf.objectSomeValuesFrom = owlObjectSomeValuesFrom;
		ont.subclassof.add(owlSubClassOf);
	}
	
	if (not owlObjectIntersectionOfMin.class.isEmpty()) {
		owlObjectMinCardinality.objectIntersectionOf = owlObjectIntersectionOfMin;
		var cardinality = new Native("java.math.BigInteger")("0");
		owlObjectMinCardinality.cardinality = cardinality;
		owlSubClassOfMin.objectMinCardinality = owlObjectMinCardinality;
		("OwlSubClassOfMin: " + branch.name + " " + owlObjectIntersectionOfMin).println();
		ont.subclassof.add(owlSubClassOfMin);
	}
}

// Add or object property between ontology classes
operation addOrObjProp(owlSubClassOf : owl!SubClassOf, owlClass : owl!Class, owlOP : owl!ObjectProperty, branch : fm!BranchType) {
	// Add class
	owlClass.iri = generateOwlClassIRI(branch.name);
	owlSubClassOf.class.add(owlClass);

	owlOP.iri = branch.generateOwlObjectPropertyIRI();
	
	var owlObjectSomeValuesFrom : new owl!ObjectSomeValuesFrom;
	var owlObjectUnionOf : new owl!ObjectUnionOf;
	
	owlObjectSomeValuesFrom.objectProperty = owlOP;
	
	for (feature in branch.feature) {
			// Create childs for every branch in the feature model
			var owlChildClass : new owl!Class;				
			owlChildClass.iri = feature.equivalent().class.iri;	
			// Add the child elements to the ObjectUnionOf MM class
			owlObjectUnionOf.class.add(owlChildClass);
	}
	
	for (subBranch in branch.And) {
		// Create childs for every branch in the feature model
		var owlChildClass : new owl!Class;				
		owlChildClass.iri = subBranch.equivalent().class.iri;	
		// Add the child elements to the ObjectUnionOf MM class
		owlObjectUnionOf.class.add(owlChildClass);
	}
	
	for (subBranch in branch.Or) {
		// Create childs for every branch in the feature model
		var owlChildClass : new owl!Class;				
		owlChildClass.iri = subBranch.equivalent().class.iri;	
		// Add the child elements to the ObjectUnionOf MM class
		owlObjectUnionOf.class.add(owlChildClass);
	}
	
	for (subBranch in branch.alt) {
		// Create childs for every branch in the feature model
		var owlChildClass : new owl!Class;				
		owlChildClass.iri = subBranch.equivalent().class.iri;	
		// Add the child elements to the ObjectUnionOf MM class
		owlObjectUnionOf.class.add(owlChildClass);
	}
	
	// Add the ObjectUnionOf element to the ObjectSomeValuesFrom MM class
	owlObjectSomeValuesFrom.objectUnionOf = owlObjectUnionOf;	
	owlSubClassOf.objectSomeValuesFrom = owlObjectSomeValuesFrom;
	ont.subclassof.add(owlSubClassOf);
}*/


operation fm!BranchType hasSubclasses (): List {
   var subClasses = new List;
   for (branch in featureRelations!SubClassRelation) {
      if ((branch.SuperBranch = self) and not branch.SuperBranch.hasIndividual ()){
	     for (feat in branch.SubFeature) {
	        subClasses.add (feat);
	        }
	     for (bran in branch.SubBranch) {
	        subClasses.add (bran);
	        }	       
	  }  
   }
   return subClasses;
}

operation fm!BranchType isSubclass (): Boolean {
   for (branch in featureRelations!SubClassRelation) {
	     for (bran in branch.SubBranch) {
	        if (bran = self){
	        return true;}
	        }
   }
   return false;
}

operation fm!FeatureType isIndividual (): Boolean {

   for (branch in featureRelations!SubClassRelation) {
      if (branch.hasIndividuals){
	     for (feat in branch.SubFeature) {
	        if (feat = self){
	           return true;
	        }
	     }	      
	  }
   }
   return false;  
}

operation fm!FeatureType isDisabled (): Boolean {
   for (feat in featureRelations!Disabled) {
       
     if (feat.features.indexOf (self) <> -1){
        return true;
     }
   }   
   return false;  
}

operation fm!BranchType isDisabled (): Boolean {
   for (branch in featureRelations!Disabled) {
     if (branch.branches.indexOf (self) <> -1){
        return true;
     }
   }   
   return false;  
}


operation fm!BranchType hasIndividual (): Boolean {
   for (branch in featureRelations!SubClassRelation) {
      if ((branch.SuperBranch = self) and (branch.hasIndividuals)){
	     return true;
      }
   }      
   return false;  
}

operation owl!Class ontHierarchy (superClass : owl!Class) {
	var owlSubClass : new owl!SubClassOf;
	var owlParentClass : new owl!Class;
	var owlChildClass : new owl!Class;
	
	owlChildClass.iri = self.iri;
	owlSubClass.class.add(owlChildClass);
	owlParentClass.iri = superClass.iri;
	owlSubClass.class.add(owlParentClass);
	ont.subclassof.add(owlSubClass);
}


operation owl!Class ontHierarchyShared (superClassName : String) {
	var owlSubClass : new owl!SubClassOf;
	var owlParentClass : new owl!Class;
	var owlChildClass : new owl!Class;
	
	owlChildClass.iri = self.iri;
	owlSubClass.class.add(owlChildClass);
	owlParentClass.iri = generateOwlClassIRI (superClassName);
	owlSubClass.class.add(owlParentClass);

	ont.subclassof.add(owlSubClass);
}